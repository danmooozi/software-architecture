## **16.1** 역사와 철학

많은 기업들은 가변적 인 확장성 등 다른 유용한 특성을 요구했습니다. 이 시대의 아키텍트들은 다양한 외부 여건 탓에 어쩔 수 없이 제약이 많은 분산 아키텍처를 구축했습니다.

아키텍트는 최대한 재사용하는 것을 목표로 삼게 되었고, 실제로 모든 형태의 재사용은 이 아키텍처의 중심 철학이 되었습니다（그 부수효과는 16.4절에서 다룹니다）

이 아키텍처 스타일은 아키텍트가 기술 분할에 집착하면 어떻게 되는지 잘 보여주는 사례입니다. 취지는 좋았으나 결과는 좋지 않았죠.

## **16.2** 토폴로지

![image](https://github.com/user-attachments/assets/9c9b488f-cc23-4596-8ead-26dc348d336e)

모든 아키텍처에 ［그림 16-1］과 동일한 레이어가 있는 건 아니지만, 아키텍처 내부에 서비스 택소노미를 정립하여 레이어별로 책임을 지운다는 아이디어는 동일합니다. 서비스 지향 아키텍처는 분산 아키텍처입니다. 분산 아키텍처는 조직마다 다양하므로 정확한 경계선은 ［그림 16-1］에 표시하지 않았습니다.

## **16.3** 택소노미

이 아키텍처의 중심 철학은 엔터프라이즈 레벨의 재사용입니다.

### **16.3.1** 비즈니스서비스

이 서비스 정의는 코드는 전혀 없고, 입력, 출력, 스키마 정보만 갖고 있습니다. 서비스는 대부분 비즈니스 유저가 정의하기 때문에 이름도 비즈니스 서비스입니다.

### **16.3.2** 엔터프라이즈 서비스

엔터프라이즈 서비스는 세분화된 공유 구현체를 포함합니다. 일반적으로 개발팀은 특정 비즈니스 도메인에 관한 원자적 행위를 구현하는 업무를 담당합니다. 이런 서비스는 오케스트레이션 엔진을 통해 묶인, 단위가 큰 비즈니스 서비스를 구성하는 요소들입니다.

이 아키텍처의 재사용 목표 때문에 이렇게 책임을 분리한 것입니다. 비즈니스는 재사용 가능한 엔터프라이즈 서비스 형태로 재사용 가능한 자산을 구축할 수 있을 거라고 믿었습니다.

### **16.3.3** 애플리케이션 서비스

아키텍처의 모든 서비스에서 엔터프라이즈 서비스와 동일한 레벨의 세분화 또는 재사용이 필요한 것은 아닙니다. 애플리케이션 서비스는 한 번만 사용 가능한 단일 구현체 서비스입니다.

### **16.3.4** 인프라 서비스

인프라 서비스는 모니터링, 로깅, 인증/인가 등의 운영 관심사를 지원합니다. 이런 서비스는 운영팀과 긴밀하게 협업하는 공유 인프라팀이 소유한 실질적인 구현체인 경우가 많습니다.

### **16.3.5** 오케스트레이션 엔진

오케스트레이션 엔진은 이 분산 아키텍처의 요체입니다. 이 엔진은 비즈니스 서비스 구현체를 서로 엮어주며 트랜잭션 조정과 메시지 변환 등의 기능을 수행합니다. 마이크로서비스 아키텍처처럼 서비스마다 데이터베이스가 있는 것은 아니며, 일반적으로 단일 관계형 데이터베이스를 사용합니다. 따라서 트랜잭셔 널 로직은 데이터베이스가 아닌 오케스트레이션 엔진에서 선언적으로 처리됩니다.

오케스트레이션 엔진은 비즈니스와 엔터프라이즈 서비스의 관계, 이 둘을 매핑하는 방법, 트랜잭션 경계는 어디까지인지 등을 정의합니다. 또한 이 엔진은 통합 허브 역할도 겸하므로 아키텍트가 커스텀 코드를 패키지와 레거시 소프트웨어 시스템에 통합할 수 있습니다.

### **16.3.6** 메시지 흐름

모든 요청은 오케스트레이션 엔진을 흘러갑니다. 이 아키텍처는 모든 로직이 오케스트레이션 엔진에 있으므로 심지어 내부 호출을 할 때에도 메시지는 엔진을 경유합니다.

![image](https://github.com/user-attachments/assets/ea1d96ac-8bdc-4cb9-8fb6-f942d64fafff)

## **16.4** 재사용… 그리고 커플링

이 아키텍처의 주된 목표는 서비스 레벨의 재사용, 즉 시간이 지남에 따라 재사용 가능한 비즈니스 행위를 점진적으로 구축하는 능력입니다. 아키텍트는 어떻게 하든지 재사용할 기회를 찾아내도록 가르침을 받았죠.

![image](https://github.com/user-attachments/assets/07a93eff-cbf4-49e7-8a78-a4b73f76b3ec)

그러나 이 설계의 어두운 그림자가 서서히 드러나기 시작합니다.

첫째, 재사용 위주로 시스템을 구축하다 보니 컴포넌트 간의 커플링이 심하게 발생합니다. **Customer** 서비스를 함부로 변경하면 다른 모든 서비스에 영향을 미치므로 위험합니다. 서비*스* 지향 아키텍처에서는 사소한 변경 하나도 그 여파를 무시할 수 없으므로 아키텍트가 점진적인 변화를 추구하기가 어렵습니다.

또 로직을 한 곳에 통합하는 것은 또 다른 부작용을 일으킵니다. ［그림 **16-4］**를 다시 보면. 하나의 **Customer** 서비스에 고객에 관한 모든 상세 정보를 담아야 합니다. 장애 문제를 관리하는 팀이 부가적인 고객 정의의 복잡성까지 떠안을 수밖에 없는 구조입니다.

기술 분할에 집중한 아키텍처 구축이 얼마나 비현실적인지 깨닫는 과정에서 이 아키텍처의 가장 유해한 부분이 밝혀지기 시작했습니다. 분리와 재사용 철학의 관점에서는 일리가 있는 보였지만 실제로는 악몽이었습니다.

## **16.5** 아키텍처 특성 등급

서비스 지향 아키텍처는 어쩌면 지금까지 시도된 아키텍처 중에서 가장 기술적으로 분할된 범용 아키텍처일 것입니다! 실제로 이 구조의 단점에 대한 반발로 인해 마이크로서비스 같은 보다 현대적인 아키텍처가 탄생하게 되었습니다.

![image](https://github.com/user-attachments/assets/1390de5f-881e-4720-8364-e080fa128b17)

배포성, 시험성 같은 요즘의 엔지니어링 목표는 이 아키텍처에서 별점이 아주 낮습니다.

이 아키텍처는 탄력성, 확장성 같은 특성을 일부 지원하지만 구현하기는 상당히 까다롭습니다.

이런 모든 팩터를 종합해보면, 단순성과 비용은 대부분의 아키텍트가 선호하는 바와 반비례합니다. 이 아키텍처는 분산트랜잭션이 실세계에서 얼마나 구현하기 어려운지, 기술 분할의 실제 한계가 무엇인지 생생하게 가르쳐준, 아주 중요한 이정표였습니다.
