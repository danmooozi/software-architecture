# 오케스트레이션 기반 서비스 지향 아키텍처 스타일

아키텍처 스타일은 해당 시대의 맥락에서 이해해야 하며, 특히 이 장에서 다루는 아키텍처가 그러합니다.  
논리적으로 보이지만 재앙과 같은 조직 철학과 맞물린 결과로, 부적절한 아키텍처가 탄생한 예시입니다.

## 16.1 역사와 철학

서비스 지향 아키텍처는 1990년대 후반에 등장했습니다.  
당시 대기업들은 인수 합병을 통해 빠르게 성장하면서 고도화된 IT가 필요했습니다.  
기업들은 가변적 확장성과 같은 추가적인 특성들을 요구하면서 분산 컴퓨팅 수요가 증가하고 있었지만, 이를 뒷받침할 컴퓨팅 리소스가 부족했습니다.  
이 시대의 아키텍트들은 불가피하게 제한적인 분산 아키텍처를 구축했습니다.  
오픈 소스 운영 체제가 신뢰를 얻기 전이라 라이선스 비용을 들여서 상용 운영 체제를 사용해야 했으며, 데이터베이스도 마찬가지로 라이선스 비용을 들여서 상용 DB를 사용 했습니다.  
이에 따라 아키텍트들은 최대한 리소스를 재사용하는 것을 목표로 했고, 이는 아키텍처의 중심 철학이 되었습니다.  
이에 따라 기술 분할에 집착하게 되었는데, 이는 좋지 않은 결과를 낳았습니다.

## 16.2 토폴로지

서비사 지향 아키텍처는 서비스 택소노미(분류체계)를 통해 레이어별로 책임을 분담한다는 아이디어를 기반으로 합니다.

그림 16-1

## 16.3 택소노미

이 아키텍처의 핵심 철학은 엔터프라이즈 레벨의 재사용이며, 각 레이어로 구성된 택소노미를 통해 이를 달성합니다.

### 16.3.1 비즈니스 서비스

서비스 지향 아키텍처의 최상단에는 비즈니스 서비스가 진입점으로써 위치하며, ExecuteTrade나 PlaceOrder 같은 이름을 가져서 하나의 도메인 행위를 나타냅니다.  
대부분 비즈니스 유저가 서비스를 정의하여, 코드 없이 입력, 출력, 스키마 정보만 갖고 있습니다.

### 16.3.2 엔터프라이즈 서비스

엔터프라이즈 서비스는 특정 비즈니스 도메인의 원자적 행위(예: CreateCustomer, CalculateQuote)에 대한 구현체 입니다.  
엔터프라이즈 서비스들은 오케스트레이션 엔진을 통해단위가 더 큰 비즈니스 서비스를 구성합니다.  
이는 서비스의 책임을 분리한 것으로, 이를 통해 비즈니스 워크플로의 중복을 줄이는 것이 목표입니다.  
그러나 소프트웨어의 비즈니스 컴포넌트는 시장, 기술 변화, 엔지니어링 프랙티스 등 다양한 요인으로 인해 불규칙하게 변화하기 때문에, 이러한 재사용 시도는 실패했습니다.

### 16.3.3 애플리케이션 서비스

애플리케이션 서비스는 한 번만 사용되는 단일 구현체입니다.  
모든 서비스가 세분화 및 재사용이 필요한 것은 아니기 때문에, **특정 어플리케이션에서만 필요로 하는 서비스는 해당 팀이 소유한 애플리케이션 서비스로 구성**합니다.

### 16.3.4 인프라 서비스

인프라 서비스는 모니터링, 로깅, 인증/인가 등 운영에 필요한 기능을 지원하는 구현체이며, 주로 운영팀과 협업하는 공유 인프라팀이 소유합니다.

### 16.3.5 오케스트레이션 엔진

오케스트레이션 엔진은 분산 아키텍처의 핵심으로, **비즈니스 서비스 구현체를 연결**하고 **트랜잭션 조정과 메시지 변환을 수행**합니다.  
서비스 지향 아키텍처에서는 서비스마다 별도의 데이터베이스를 두지 않고 단일한 관계형 데이터베이스를 사용하며, DB에 대한 트랜잭션 로직은 오케스트레이션 엔진에서 선언적으로 처리됩니다.

오케스트레이션 엔진은 비즈니스와 엔터프라이즈 서비스를 매핑하는 방법을 정의하고, 트랜잭션 경계를 설정합니다.  
또한 통합 허브 역할을 하여 아키텍트가 커스텀 코드를 레거시 시스템과 통합할 수 있도록 돕습니다.  
트랜잭션 로직을 오케스트레이션 도구에 위임하는 아이디어는 매력적이었으나, 트랜잭션을 어느 수준까지 세분화할지 결정하기 어려웠습니다.  
서비스 간의 트랜잭션 경계를 개발자가 직접 알아내야 해서 아키텍처가 더욱 복잡해졌습니다.

### 16.3.6 메시지 흐름

서비스 지향 아키텍처에서 모든 요청은 오케스트레이션 엔진을 거치며, 내부 호출조차 엔진을 통해 이루어집니다.  
아래 예제에서 CreateQuote 서비스는 엔터프라이즈 서비스 버스를 호출하고, 서비스 버스는 CreateCustomer와 CalQuote 호출로 구성된 워크플로를 실행하여, 각 애플리케이션 서비스를 호출합니다.  
이 때 서비스 버스는 아키텍처 내부의 모든 호출을 중계하여, 통합 허브와 오케스트레이션 엔진 역할을 겸하게 됩니다.

그림 16-2

## 16.4 재사용... 그리고 커플링

이 아키텍처의 주요 목표는 서비스 레벨의 재사용으로, 재사용 가능한 비즈니스 행위를 점진적으로 구축해나가는 것입니다.  
다음의 예제에서는 보험 회사의 모든 부서에 ‘Customer’ 개념이 포함된 것을 식별할 수 있습니다.  
이런 경우에는 고객 관련 로직을 재사용 가능한 서비스로 분리하고, 기존 서비스가 표준 고객 서비스를 참조하도록 하는 것이 최선의 전략입니다.

그림 16-4

하지만 재사용을 강조하다 보니 컴포넌트 간의 결합이 강해져서, 변경 시 위험이 커졌습니다.  
예제에서는 Customer 서비스의 작은 변경이 다른 모든 서비스에 영향을 미칩니다.  
서비스 지향 아키텍처에서는 사소한 변경도 그 영향을 무시할 수 없어, 서비스의 점진적인 변화를 추구하기 어렵습니다.  
서비스를 수정하기 위해서는 아키텍처 전반의 배포 조정과 전체 테스트가 필요해, 엔지니어링 효율이 크게 떨어집니다.  
또한 로직을 한 곳에 통합하다보면, 복잡성 또한 한 서비스에 집중됩니다.  
예제의 Customer 서비스는 고객의 모든 상세 정보를 포함해야 하므로, 예를 들어 자동차 보험에 필요한 운전 면허증 정보도 포함하게 됩니다.  
그 결과, 다른 팀들도 불필요한 고객 정보 복잡성까지 관리해야 합니다.

서비스 지향 아키텍처는 도메인 개념이 전체 아키텍처에 얇게 분산됩니다.  
‘CatalogCheckout에 새 주소 라인 추가’ 같은 간단한 작업조차, 데이터베이스의 스키마 변경과 함께 여러 티어에 걸쳐 있는 수많은 서비스의 변경을 유발할 수 있습니다.  
또한 트랜잭션이 제대로 세분화되지 않은 경우, 개발자는 트랜잭션 로직을 변경하기 위해 서비스 설계를 변경하거나 거의 동일한 서비스를 새로 만들어야 합니다.

## 16.5 아키텍처 특성 등급

서비스 지향 아키텍처는 기술적으로 가장 분할된 분산 아키텍처이지만, 퀀텀 수는 1개로 제한됩니다.  
보통 단일 데이터베이스를 사용하기 때문에, 다수의 상이한 관심사 사이에도 커플링이 발생합니다.
또한 오케스트레이션 엔진이 모든 동작을 조정하는 중재자로 기능하여, 아키텍처 전체에서 동일한 아키텍처 특성을 강제하는 단일한 커플링 지점으로 작용합니다.  
이로 인해 결국 이 아키텍처는 모놀리식과 분산 아키텍처의 단점을 모두 지니게 됩니다.
