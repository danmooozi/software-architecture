# 16장. 오케스트레이션 기반 서비스 지향 아키텍처 스타일

- 조직 내부의 아이디어가 어떻게 개발 프로세스의 핵심을 망가뜨릴 수 있는지를 보여주는 대표적인 사례

---

## 16.1 역사와 철학

**서비스 지향 아키텍처 (SOA)** 는 **1990년대 후반**에 등장:

1. **등장 배경**: 대기업의 인수 합병으로 **세련된 IT 인프라**가 필요했으나, 당시에는 **컴퓨팅 리소스**가 부족하고 상용 제품에 의존.
2. **기술적 제약**: **오픈 소스 운영 체제** 신뢰 부족, **비싼 라이선스 비용**, **데이터베이스 벤더와 애플리케이션 서버 벤더** 간의 경쟁 구도.
3. **중심 철학**: **재사용성** 극대화를 목표로 했으나, **기술 분할**에 집착하면서 결과적으로 **효과적인 성과를 내지 못한 사례**.

---

## 16.2 토폴로지

- **서비스 지향 아키텍처 (SOA)** 는 **분산 아키텍처**의 한 형태:
1. **서비스 택소노미**: 모든 아키텍처가 동일한 레이어를 가지진 않지만, **서비스 분류체계**를 통해 레이어별로 **책임을 명확히 구분**.
2. **분산 특성**: **조직마다 구현 방식이 다양**하기 때문에, SOA의 **정확한 경계선**은 명확히 정의되지 않는다.
3. **유연성 강조**: 각기 다른 **서비스 레이어**를 통해 시스템을 구성해 **확장성과 재사용성**을 높이는 것이 핵심.

---

## 16.3 택소노미(분류 체계)

1. **중심 철학**: 이 아키텍처의 핵심은 **엔터프라이즈 레벨의 재사용**.
2. **배경**: 소프트웨어 수정에 지친 대기업들이 **효율적인 해결책**을 모색한 결과로 등장.
3. **실현 방법**: **서비스 택소노미의 각 레이어**를 통해 **재사용성**을 극대화하여 문제를 해결.

### 16.3.1 비즈니스 서비스

1. **비즈니스 서비스**: 아키텍처의 **최상단 레이어**로, **진입점 역할**을 합니다. 예시로는 `ExecuteTrade`, `PlaceOrder` 등이 있다.
2. **목적**: 각 서비스는 특정 **도메인 행위**를 나타내며, 당시 아키텍트들은 **“우리가 비즈니스를 하고 있나요?”** 라는 질문에 답할 수 있는지로 유효성을 평가했다.
3. **구성 요소**: 이 서비스 정의에는 **코드가 없고**, **입력/출력 및 스키마 정보**만 포함되어 있습니다. 주로 **비즈니스 유저**에 의해 정의되기 때문에 **비즈니스 서비스**라고 불린다.

### 16.3.2 엔터프라이즈 서비스

1. **엔터프라이즈 서비스 (Enterprise Service)**: **세분화된 공유 구현체**를 포함하며, 특정 **비즈니스 도메인**(예: `CreateCustomer`, `CalculateQuote`)에 대한 **원자적 행위**를 구현.
2. **구성 및 목적**: 이 서비스들은 **오케스트레이션 엔진**을 통해 **큰 단위의 비즈니스 서비스**를 구성하는 요소로 사용됩니다. **재사용성**을 높이기 위해 **책임을 분리**한 것.
3. **재사용 목표**: 정확한 **세분도에 맞게 엔터프라이즈 서비스**를 구축하면, 해당 비즈니스 워크플로를 **재작성할 필요가 없을 것**으로 기대했다.
4. **실제 문제**: 그러나 **소프트웨어의 변화무쌍한 특성**(시장 변화, 기술 발전 등)으로 인해 **안정적인 재사용 자산 구축**은 어려웠고, 결국 **이 시도는 실패**로 귀결되었다.

### 16.3.3 애플리케이션 서비스

1. **애플리케이션 서비스 (Application Service)**: **단일 구현체 서비스**로, 한 번만 사용되도록 설계된 서비스.
2. **특징 및 사용 사례**:
    - **특정 애플리케이션에만 필요한 기능**(예: 지리적 위치 정보)을 제공.
    - **재사용 가능성**을 고려하지 않고, **개별 애플리케이션 팀이 소유**.
3. **구현 목적**:
    - 조직이 **시간과 리소스를 절약**하면서 **필요한 기능만 빠르게 구현**하기 위해 사용.
    - **엔터프라이즈 서비스처럼 세분화되거나 재사용될 필요가 없는 경우**에 유용.

### 16.3.4 인프라 서비스

- **특징 및 사용 사례**:
    - **모니터링, 로깅, 인증/인가** 등의 기능 제공.
    - **운영팀과 협력**하여 시스템의 안정성과 보안을 강화합니다.
- **소유 및 관리**:
    - 주로 **공유 인프라팀**에서 관리하는 **실질적인 구현체**입니다.
    - 여러 시스템에서 **공통적으로 활용**될 수 있도록 설계됩니다.

### 16.3.5 오케스트레이션 엔진

1. **오케스트레이션 엔진 (Orchestration Engine)**: 이 분산 아키텍처의 **핵심 요소**.
2. **주요 기능**:
    - **비즈니스 서비스 구현체를 엮어주는 역할**.
    - **트랜잭션 조정**, **메시지 변환** 등을 처리.
    - **단일 관계형 데이터베이스**를 사용하며, 트랜잭셔널 로직은 엔진에서 **선언적으로 처리**.
3. **역할**:
    - **비즈니스와 엔터프라이즈 서비스 간 관계**와 **트랜잭션 경계**를 정의.
    - **통합 허브 역할**도 수행하여 **레거시 시스템과의 통합**을 지원.
4. **문제점**:
    - 트랜잭셔널 로직을 엔진에 위임하는 방식은 **이론적으로는 매력적**이었으나, **트랜잭션 경계를 세분화**하는 일이 어려워졌다.
    - 서비스 간 **분산 트랜잭션**을 개발하면서 **아키텍처의 복잡도가 증가**했다.
    - **통합 아키텍트 팀**이 조직 내에서 **정치적 병목**이 되는 문제를 야기했다.

### 16.3.6 메시지 흐름

1. **오케스트레이션 엔진**:
    - 모든 **요청**은 오케스트레이션 엔진을 통해 흐릅니다.
    - **내부 호출**도 엔진을 경유하여 처리됩니다.
2. **서비스 버스 (Service Bus)**:
    - **CreateQuote 서비스**는 서비스 버스를 호출합니다.
    - 서비스 버스는 **워크플로**를 정의하고, 이 워크플로에는 **CreateCustomer**와 **CalQuote** 호출이 포함됩니다.
    - **서비스 버스**는 아키텍처 내의 모든 호출을 **중계**하며, **통합 허브**와 **오케스트레이션 엔진**의 두 역할을 동시에 수행합니다.

## 16.4 재사용… 그리고 커플링

이 아키텍처의 주된 목표와 그로 인한 문제점들을 정리해보면 다음과 같다:

1. **목표**:
    - 서비스 레벨에서의 **재사용**을 통해 비즈니스 행위를 점진적으로 구축하는 것이 핵심.
    - 아키텍트는 **재사용할 기회를 찾는** 것을 중요시하며, 이를 통해 시스템을 개선하려고 했다.
2. **[그림 16-3]과 16-4**:
    - **Customer 서비스**를 독립된 재사용 가능한 서비스로 분리하여, 고객에 관련된 모든 행위를 표준화하고 재사용성을 높였다.
    - 이로 인해 보험 회사의 모든 부서가 동일한 고객 관련 서비스(Customer)를 참조하도록 구조화되었다.
3. **문제점**:
    - **커플링** 문제: 서비스가 서로 강하게 연결되어 있어, **Customer 서비스**의 변경이 다른 서비스에 미치는 영향을 감당하기 어렵다. 이는 **변경에 대한 유연성을 떨어뜨리고** 전체 테스트와 배포에 많은 어려움을 초래.
    - **로직 통합의 문제**: 모든 고객 정보를 하나의 서비스에 통합함으로써, 고객의 다양한 세부 정보(예: 면허증 정보)가 필요 없는 부서까지 불필요하게 포함된다. 이는 **복잡성 증가**와 **부서 간 불필요한 부담**을 초래.
    - **재사용의 부작용**: 재사용을 목표로 한 설계가 **비현실적**으로 드러나면서, 작은 변경조차 여러 서비스와 데이터베이스 스키마 변경을 유발하게 된다. 이로 인해 개발자는 많은 **트랜잭셔널 로직**을 새로 정의하거나, 기존 서비스를 수정해야 하는 상황에 놓이게 된다.

결국, 이 아키텍처는 **재사용을 지나치게 강조**함으로써 시스템을 복잡하고 취약하게 만들었으며, **엔지니어링 효율성**과 **변경의 유연성**을 크게 저하시켰다.

## 16.5 아키텍처 특성

이 아키텍처와 관련된 주요 평가 사항을 정리하면 다음과 같다:

1. **기술적 분할**:
    - 서비스 지향 아키텍처(SOA)는 기술적으로 매우 **분할된 범용 아키텍처**. 하지만 이로 인해 발생한 **커플링** 문제와 **중재자 역할**을 하는 오케스트레이션 엔진이 중요한 단점으로 작용한다.
2. **단점과 문제점**:
    - **단일 데이터베이스 사용**: 많은 조직이 여러 데이터베이스를 사용하지 않고 단일 데이터베이스로 여러 관심사를 처리하며, 이로 인해 아키텍처 내에서 **강한 커플링 지점**이 생긴다.
    - **오케스트레이션 엔진의 역할**: 오케스트레이션 엔진이 모든 동작을 조정하는 **중재자 역할**을 하게 되어, 아키텍처의 다른 부분들과는 다른 특성을 가질 수 없습니다. 이로 인해 **모놀리식 아키텍처**와 **분산 아키텍처**의 단점이 동시에 나타난다.
3. **애자일과의 불일치**:
    - **애자일 소프트웨어 프랙티스**가 시작되었을 때, 이 아키텍처는 **애자일 환경**에 잘 맞지 않았다. 당시의 아키텍처에서는 애자일 프로세스를 도입하기 어려운 구조였고, 그로 인해 **마이크로서비스 아키텍처**와 같은 **더 현대적인 아키텍처**가 발전하게 되었다.
4. **서비스 지향 아키텍처의 평가**:
    - **강점**: 서비스 지향 아키텍처는 **서비스 레벨에서의 재사용**을 강조하고, 여러 서비스들이 서로 독립적으로 동작하는 형태로 구조화된다.
    - **약점**: 하지만, 이 아키텍처는 **구성 요소들 간의 강한 의존성**과 **변경에 대한 유연성 부족**을 유발하며, 복잡성 증가와 관리의 어려움을 초래한다.

결국, 서비스 지향 아키텍처는 **재사용성과 유연성**을 높이려는 목표를 가지고 시작했지만, **구현의 복잡성**과 **유지보수의 어려움**을 겪게 되었다. 이로 인해 **마이크로서비스**와 같은 새로운 아키텍처 스타일이 더 널리 사용되기 시작한 배경이 된다.
