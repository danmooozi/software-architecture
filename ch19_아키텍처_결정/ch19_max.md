> 아키텍트는 정보를 수집하고, 결정을 정당화 및 문서화하며, 이해관계자와 소통하여 개발팀의 기술 선택을 돕는 아키텍처 결정을 내린다.
> 

## **19.1** 아키텍처 결정 안티패턴

1. **아키텍트의 기술적 결정**
    
    아키텍트의 아키텍처 결정은 시스템 구조뿐만 아니라 아키텍처 특성에 영향을 미치는 기술 선택도 포함된다. 올바른 결정은 개발팀의 기술 선택에 발판이 된다.
    
2. **아키텍처 결정 과정**
    
    충분한 정보 수집 → 결정 정당화 및 문서화 → 이해관계자와 효과적 소통.
    
3. **아키텍처 안티패턴**
    - **네 패를 먼저 보여주지마**: 초기에는 좋아 보이지만 곧 문제가 드러남.
    - **무한반복 회의**: 같은 결정을 반복 논의.
    - **이메일 기반 아키텍처**: 비효율적 이메일 소통에 의존.
    세 안티패턴은 누적되기 쉬워, 모두 극복해야 정확한 아키텍처 결정을 할 수 있다.

### **19.1.1** ‘네 패를 먼저 보여주지마’ 안티패턴

1. **아키텍처 결정 회피**
    
    잘못된 선택에 대한 두려움으로 결정을 미루는 안티패턴이 발생한다.
    
2. **극복 방법**
    - **적절한 순간까지 기다리기**: 충분한 정보를 수집하되 분석 마비에 빠지지 않음.
    - **개발팀과 협력**: 협력을 통해 문제를 빠르게 인지하고 대응할 수 있음.
3. **예시**
    
    제품 데이터를 캐싱하는 아키텍처를 결정했지만, 개발팀이 확장성 문제를 발견함. 협력을 통해 문제를 수정하고 결정을 다듬어야 한다.
    

### **19.1.2 ‘**무한반복 회의’ 안티패턴

1. **‘무한반복 회의’ 안티패턴**
    
    아키텍트가 결정의 근거를 명확히 설명하지 못해 회의만 계속 반복되는 현상.
    
2. **발생 원인**
    
    아키텍처 결정의 기술적, 비즈니스적 근거를 정당화하지 못했기 때문.
    
3. **극복 방법**
    - **비즈니스 가치 제시**: 비용, 출시 시기, 유저 만족도, 전략적 포지셔닝 등으로 결정 정당화.
    - **이해관계자 맞춤 소통**: 이해관계자의 우선순위에 맞는 근거를 제시.
4. **예시**
    
    모놀리식 애플리케이션을 서비스로 분리할 때, 비용 절감뿐만 아니라 신기능 출시 속도를 강조해 비즈니스적으로 정당화한다.
    

### **19.1.3 ‘**이메일 기반 아키텍처’ 안티패턴

1. **‘이메일 기반 아키텍처’ 안티패턴**
    
    아키텍처 결정을 이메일로만 전달해 사람들이 결정을 놓치거나 잊어버리는 현상.
    
2. **발생 원인**
    
    이메일은 소통 도구로 유용하지만, 문서 저장 체계로는 부적합하기 때문.
    
3. **극복 방법**
    - **단일 기록 시스템 사용**: 이메일에는 결정의 맥락만 언급하고, 세부 사항은 위키나 문서 링크로 제공.
    - **관련자만 통지**: 결정이 직접 영향을 미치는 이해관계자에게만 알림.
4. **예시**
    
    “팀장님, 서비스 간 통신에 관한 중요한 결정을 내렸습니다. 세부 내용은 아래 링크에서 확인해주세요.”
    

## **19.2** 아키텍처적으로 중요한

1. **기술 결정 vs. 아키텍처 결정**
    
    기술 선택이 아키텍처 특성(예: 성능, 확장성)을 직접 지원하면 이는 아키텍처 결정이다.
    
2. **아키텍처적으로 중요한 결정**
    
    마이클 나이가드는 구조, 비기능 특성, 의존성, 인터페이스, 구현 기술에 영향을 미치는 결정을 아키텍처적으로 중요하다고 정의했다.
    
3. **주요 요소**
    - **구조**: 아키텍처 패턴과 스타일에 영향을 미침 (예: 마이크로서비스 간 데이터 공유).
    - **비기능 특성**: 성능, 확장성 등 시스템 특성을 결정.
    - **의존성**: 컴포넌트 간 커플링이 확장성과 안정성에 영향.
    - **인터페이스**: 서비스와 컴포넌트 간의 접근과 조정 방식 (예: API, 계약 버전).
    - **구현 기술**: 플랫폼과 프레임워크 선택이 아키텍처에 영향.

## 19.3 아키텍처 결정 레코드

1. **아키텍처 결정 레코드 (ADR)**
    
    아키텍처 결정을 효과적으로 문서화하는 방법으로, 짧은 텍스트 파일로 작성된다.
    
2. **ADR 소개**
    - **창시자**: 마이클 나이가드.
    - **형식**: 아스키독, 마크다운, 위키 페이지 템플릿 등 텍스트 포맷 사용.
    - **채택**: 쏘우트웍스 기술 레이더에서 ‘채택됨’으로 표시.
3. **ADR 도구**
    - **ADR-tools**: 냇 프라이스가 개발한 CLI 기반 오픈소스 도구.
    - **기능**: 채번 스키마, 위치 관리, 대체 로직 등을 지원.
4. **활용 사례**
    
    독일 엔지니어 미카 콥스가 ADR-tools로 아키텍처 의사 결정을 관리한 사례를 소개했다.
    

### **19.3.1** 기본구조

**아키텍처 결정 레코드 (ADR)의 기본 구조와 각 섹션 설명**

### **1. 제목 (Title)**

- **구성**: 일련 번호와 간결한 설명.
- **예시**: `42. 주문 서비스와 결제 서비스 간의 비동기 메시징 사용`
- **설명**: 결정의 핵심을 짧고 명확하게 표현하여 모호함을 피함.

---

### **2. 상태 (Status)**

- **상태 유형**:
    - **제안됨 (Proposed)**: 상위 레벨 의사결정권자의 승인이 필요.
    - **수락됨 (Accepted)**: 결정이 승인되어 구현 준비 완료.
    - **대체됨 (Superseded)**: 새로운 결정으로 대체됨.
- **예시**:
    - `ADR 42. 주문 서비스와 결제 서비스 간의 비동기 메시징 사용 → 68로 대체됨`
    - `ADR 68. 주문 서비스와 결제 서비스 간의 REST 사용 → 수락됨, 42를 대체함`

---

### **3. 콘텍스트 (Context)**

- **설명**: 결정에 영향을 미친 상황이나 제약 조건.
- **예시**:
    - `주문 서비스가 결제 금액을 처리하기 위해 결제 서비스와 정보를 공유해야 함.`

---

### **4. 결정 (Decision)**

- **설명**: 결정 사항과 그 이유를 명확하고 단호한 어조로 설명.
- **예시**:
    - `주문 서비스와 결제 서비스 간에는 비동기 메시징을 사용할 것입니다.`

---

### **5. 결과 (Consequences)**

- **설명**: 결정의 장점과 단점, 트레이드오프를 기록.
- **예시**:
    - `응답 시간이 3,100밀리초에서 25밀리초로 개선됨. 하지만 에러 처리가 복잡해짐.`

---

### **추가 섹션**

1. **컴플라이언스 (Compliance)**
    - **설명**: 결정의 준수 여부를 수동 또는 자동으로 확인하는 방법.
    - **예시**:
        - `자바 ArchUnit을 사용하여 공유 서비스 레이어 규칙 준수 여부 확인.`
2. **노트 (Notes)**
    - **설명**: 메타데이터 기록 (예: 작성자, 승인자, 수정 이력 등).
    - **예시**:

이 ADR 구조를 활용하면 아키텍처 결정을 체계적이고 명확하게 문서화할 수 있습니다.

### **19.3.2 ADR** 저장

### **ADR 저장 위치 및 디렉터리 구조 정리**

---

### **ADR 저장 위치**

1. **소스 코드 리포지터리 (Git)**
    - **장점**: 버전 관리 및 추적이 간편함.
    - **주의사항**:
        - 접근 권한이 제한될 수 있음.
        - 애플리케이션 리포지터리를 벗어난 결정에는 적합하지 않음.
2. **공유 위키 (권장)**
    - 접근성이 높고, 전사적 및 통합 아키텍처 결정을 포함할 수 있음.
3. **공유 파일 서버**
    - 문서 렌더링 소프트웨어와 함께 사용 가능.

---

### **ADR 디렉터리/네비게이션 구조**

```
ADR/
│
├── application/                # 애플리케이션 관련 아키텍처 결정
│   ├── common/                 # 모든 애플리케이션에 통용되는 결정
│   ├── ATP/                    # ATP 애플리케이션 관련 결정
│   └── PSTD/                   # PSTD 애플리케이션 관련 결정
│
├── integration/                # 애플리케이션, 시스템, 서비스 간 통신 관련 결정
│
└── enterprise/                 # 엔터프라이즈 아키텍처 결정

```

- **위키에 저장 시**: 각 디렉터리가 네비게이션 랜딩 페이지로 사용됨.
- **명칭**: 조직에 맞게 조정하되, 모든 팀에서 일관성 유지.

### 19.3.3 ADR로 문서화

ADR은 소프트웨어 아키텍처를 문서화하는 효과적인 방법입니다. ADR의 **콘텍스트 섹션**은 시스템의 특정 영역을 기술하고, 아키텍처 결정의 대안을 제시하는 데 적합합니다. **결정 섹션**은 아키텍처 결정을 내린 이유를 설명하며, **결과 섹션**은 트레이드오프 분석과 그로 인한 영향을 기록합니다. 이 세 가지 섹션을 통해 ADR은 아키텍처 문서화의 중요한 도구로, 결정의 이유와 결과를 명확히 전달합니다.

### 19.3.4 ADR로 표준화

표준을 좋아하는 사람이 있을지 모르지만, ADR을 표준화하면 그 유용성을 강조할 수 있습니다. ADR의 **콘텍스트 섹션**은 왜 특정 표준이 필요한지 설명하고, **결정 섹션**은 어떤 표준이 존재하는지와 그 이유를 제시합니다. 이를 통해 아키텍트는 표준의 타당성을 검증할 수 있으며, **결과 섹션**에서 표준의 적용이 적절한지 재검토할 수 있습니다. 이 과정은 표준을 정당화하고, 개발자들이 따를 수 있도록 설득하는 데 중요한 역할을 합니다.
