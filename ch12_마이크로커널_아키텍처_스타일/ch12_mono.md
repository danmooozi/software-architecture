# 12. 마이크로커널 아키텍처 스타일

플로그인 아키텍처라고도 함

## **12.1** 토폴로지

마이크로커널 아키텍처 스타일은 코어 시스템과 플러그인 컴포넌트라는 두 가지 아키텍처 요소로 구성된 비교적 단순한 모놀리식 아키텍처 입니다.

![image](https://github.com/user-attachments/assets/93adac94-32e9-4d17-8f68-b7997384cdda)

### **12.1.1** 코어 시스템

코어 시스템은 시스템을 실행시키는 데 필요한 최소한의 기능으로 정의합니다.

코어 시스템은 커스텀 처리가 거의/전혀 필요 없는 애플리케이션을 관통하는 정상 경로

이클립스 코어 시스템은 파일을 열고,텍스트를 고치고, 파일을 저장하는 기본적인 텍스트 에디터에 불과합니다.

코어 시스템의 순환 복잡도를 없애고 별도의 플러그인 컴포넌트를 장착하면 확장성, 유지보수성은 물론 시험성도 좋아집니다.

클라이언트에 종속된 코드를 순환 복잡도가 높은 코어 시스템에 두는 대신 각 전자 제품마다 플러그인 컴포넌트를 따로 만들어 감정하면 훨씬 더 효율적일 것입니다.

코어 시스템은 규모와 복잡도에 따라 레이어드 아키텍처나 모듈러 모놀리스로 구현할 수 있습니다. 경우에 따라 코어 시스템을 별도 배포하는 도메인 서비스로 나누어 서비스별 도메인에 특정한 플러그인 컴포넌트를 둘 수도 있습니다.

### **12.1.2** 플러그인 컴포넌트

플러그인 컴포넌트는 특수한 처리 로직, 부가 기능, 그리고 코어 시스템을 개선/확장하기 위한 커스텀 코드가 구현된 스탠드얼론 컴포넌트입니다. 변동성이 매우 큰 코드를 분리하여 애플리케이션 내부의 유지보수성, 시험성을 높이는 것입니다. 이상적인 플러그인 컴포넌트는 상호 독립적이며 의존성이 없습니다.

플러그인 컴포넌트는 컴파일 기반 또는 런타임 기반으로 만들 수 있습니다

## **12.2** 레지스트리

코어 시스템은 어떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야 하는지 알고 있어야 합니다. 가장 일반적인 구현 방법은 플러그인 레지스트리를 경유하는 것입니다. 

이 레지스트리에는 플러그인 명칭, 데이터 계약, 세부 원격 액세스 프로토콜 등 각 플러그인 모듈에 관한 정보가 있습니다.

레지스트리는 코어 시스템이 소유한 （키와 플러그인 컴포넌트 레퍼런스가 포함된） 내부 맵 구조처럼 단순할 수도 있고, 레지스트리 및 디스커버리 도구가 코어 시스템이나 외부 배포된 시스템에 내장된 복잡한 형태일 수도 있습니다.

## **12.3** 계약

플러그인 컴포넌트와 코어 시스템 간의 계약은 보통 플러그인 컴포넌트의 도메인 단위로 표준화되어 있고, 플러그인 컴포넌트가 수행하는 기능 및 입출력 데이터는 계약에 명시되어 있습니다. 서드파티 회사가 개발한 플러그인 컴포넌트의 계약을 여러분 마음대로 바꿀 수 없을 때에는 보통 커스텀 계약을 사용하며, 일반적으로 코어 시스템이 각 플러그인별 코드를 필요로 하지 않도록 플러그인 계약과 여러분이 정한표준 계약 간의 어댑터를 만듭니다.

## **12.4** 실제 용례

이클립스 **IDE, PMD,** 지라젠킨스 등 많은 소프트웨어 개발/릴리스 도구가 마이크로커널 아키텍처를 사용해서 개발됐습니다. 크롬, 파이어폭스 같은 인터넷 웹 브라우저도 마이크로커널 아키텍처를 응용한 제품으로 각종 뷰어와 플러그인을 장착하면 코어 시스템에 해당하는 기본 브라우저에 없는 부가 기능을 덧붙일 수 있습니다.

## **12.5** 아키텍처 특성 등급

마이크로커널 아키텍처도 레이어드 아키텍처처럼 단순성과 전체 비용은 주요 강점입니다. 반면, 고질적인 모놀리식 배포 탓에 확장성, 내고장성, 확장성은 *주요* 약점입니다. 모든 요청은 코어 시스템을 통해 유입되어 독립적인 플러그인 컴포넌트로 흘러가므로 퀀텀은 언제나 1 입니다. 

마이크로커널 아키텍처는 도메인 분할, 기술 분할이 모두 가능한 유일한 아키텍처 스타일입니다.

커스터마이징, 기능 신장성에 중점을 둔 제품이나 애플리케이션도 마찬가지입니다.
