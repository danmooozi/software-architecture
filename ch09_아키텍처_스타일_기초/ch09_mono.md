# 9.기초

아키텍처 스타일은 각 명칭마다 설계 패턴의 존재 이유이기도 한 상당히 많은 세부 내용이 함축되어 있습니다. 또 아키텍처 스타일은 토폴로지와 기본 전제된 아키텍처 특성을, 이로운 것과 해로운 것 모두 기술합니다. 아키텍트는 규모가 더 큰 패턴에서 나타나는 몇 가지 근본적인 패턴들을 꿰고 있어야 합니다.

## 9.1 기초 패턴

### 9.1.1 진흙잡탕

뭐 하나 뚜렷한 아키텍처 구조가 전무한 상태를 진흙잡탕이라고 표현합니다. 

```jsx
진흙잡탕은 대충 되는 대로, 아무렇게나 막 지저분하게,
테이프를 덕지덕지 붙여 놓은 스파게티 코드 정글입니다.
이런 시스템은 거의 반드시 무질서한 성장과 반복적인 땜질식 수리의 징후를 보입니다.
정보는 멀찍이 떨어져 있는 시스템 파트끼리 난잡하게 공유되고,
거의 모든 중요한 정보는전역에 흩어져 있거나 중복된 경우도 많습니다.
전체적인 시스템 구조는 한 번도 제대로 정의된 적이 없겠죠.
이 정도면 알아보기 힘들 정도로 손상돼 있을 겁니다.
아키텍처 마인드를 조금이라도 갖고 있는 프로그래머라면 고생길을 자처할 이유가 없지요.
아키텍처에 무심한 사람들,그리고 어쩌면 이런 실패한 둑의 구멍을 메우는 
일상적인 허드렛일을 하면서 관성에 빠진 사람들만이 그럭저럭 만족하며일하고 있을 것입니다.
```

진흙잡탕은 요즘에는 보통 실제 내부 구조라 할 만한 것은 하나도 없는,데이터베이스를 직접 호출하는 이벤트 핸들러를 가진 단순한 스크립팅 애플리케이션을 가리킵니다.

굳이 따지자면, 회사에서 사용하는 운영 스크립트들이 여기에 속한다고 생각한다.

물론 스크립트들 정도는 짧아서 괜찮다고 볼 수 있지만, 다음 그림에서 원 둘레의 각 점은 클래스, 각 선은 클래스 간 연결을 의미합니다. 선 이 굵을수록 더 강하게 커플링됐다는 뜻입니다.

![image](https://github.com/user-attachments/assets/b1ca093f-7205-43d3-9c3e-32f14bfdb730)

극단적인 예시지만 이렇게 서비스 하는 사람도 있다.

### **9.1.2** 유니터리 아키텍처

소프트웨어 태동기에는 단 1 대의 컴퓨터에서 소프트웨어가 돌아갔습니다. 

이제 유니터리unitary（단일, 통일 ) 시스템은 임베디드 시스템과 그 밖에 매우 제약이 많은 극소수 환경을 제외하면 거의 쓰이지 않습니다.

### 9.1.3 클라이언트/서버

프런트엔드와 백엔드로 기술적으로 기능을 분리한 2 티어 또는 클라이언트/서버 아키텍처는 대표적인 기본 아키텍처 스타일입니다.

**데스크톱 + 데이터베이스 서버**

초창기 PC 아키텍처는 개발자가 윈도우 같은 UI를 기반으로 리치 데스크톱 애플리케이션를 개발하도록 적극 지원했습니다. 데이터는 별도의 데이터베이스 서버로 분리해서 스탠드 얼론으로 운영되었었다.

**브라우저+웹 서버**

현대 웹 개발 시대가 도래하면서 웹 브라우저가 웹 서버에 접속하는（그리고 웹 서버는 다시 데이터베이스 서버에 접속하는） 형태로 분리하는 것이 일반화됐습니다.

데이터베이스는 웹 서버와 분리되어 있지만 두 서버 모두 운영 센터 내부의 동급 머신에서 운용되고 유저 인터페이스는 브라우저에서 실행되므로 여전히 이 구조를 2티어 아키텍처로 바라보는 아키텍트들도 있습니다.

**3티어 아키텍처**

![image](https://github.com/user-attachments/assets/da9155b4-0eef-446c-87ea-a9451068b65f)

1990년대 후반에 인기를 끈 3티어

고성능 데이터베이스 서버를 사용하는 데이터베이스 티어, 애플리케이션 서버가 관리하는 애플리케이션 티어,그리고 처음에는 HTML로 시작하여 기능이 점점 많아져 온갖 자바스크립트 코드로 가득 찬 프런트엔드 티어, 이렇게 3티어로 나눈 구조.

요즘은 TCP/IP 같은 네트워크 프로토콜이 어떻게 작동하는지 개발자가 （그냥 작동하니까） 신경 쓰지 않아도 되는 것처럼 아키텍트도 분산 아키텍처에서 이 정도 수준의 연결 작업에 대해서는 그리 걱정할 필요가 없습니다.

## **9.2** 모놀리식 대 분산 아키텍처

분산 아키텍처 스타일은 모놀리식 아키텍처 스타일에 비해 성능, 확장성, 가용성 측면에서 훨씬 강력하지만, 이런 파워에도 결코 무시할 수 없는 트레이드오프가 수반됩니다.

오늘날의 분산 아키텍처에서도 이 8가지 오류가 적용되는데, 하나씩 차근차근 살펴봅시다.

### **9.2.1** 오류 #1: 네트워크는 믿을 수 있다

![image](https://github.com/user-attachments/assets/ef4e97e9-146b-4222-8dea-10128ed481e0)

개발자, 아키텍트 모두 네트워크는 믿을 수 있다고 전제하지만 실제로는 전혀 그렇지 않습니다. 네트워크의 신뢰도는 점점 좋아지고 있긴 하나 아직도 미덥지 못한 게 사실입니다. 하다 못해 우리가 사용하는 회사 WiFi 도 IT 전문가가 그렇게 많은데 보장되지 않지 않은가.

타임아웃 설정을 하거나 서킷브레이커 역활을 하는것을 사이에 넣는다. AWS API Gateway 나 ELB 에서 세팅해서 해당 역활을 넣을 수 있다.

### **9.2.2** 오류 #2: 레이턴시는 0 이다.

![image](https://github.com/user-attachments/assets/5e08a9ea-87b6-426d-a519-cde445ea64cf)

아키텍트는 어떤 분산 아키텍처를 구축하든지 간에 평균 레이턴시는 반드시 알아야 합니다.

특히, 마이크로서비스는 서비스가 잘게 나뉘기 때문에 서비스 간 통신량도 만만치 않습니다. 평균 레이턴시도 중요하지만 95〜99번째 백분위수를 이해하는 것은 더 중요합니다.

저희는 APM 에서 95p 에 대해서 볼 수 있으니, 한 번 날리는 것 말고 항상 95p 구간에 레이턴시를 확인하면 좋을 것 같다고 생각한다.

### **9.2.3** 오류 #3: 대역폭은 무한하다.

![image](https://github.com/user-attachments/assets/874144ec-8ff7-4cfd-bec2-1e16e936be88)

얘도 똑같이 마이크로 서비스가 되면서 많은 대역폭이 필요하다.

만약 이름만 필요한데, 고객 프로필서비스는 *총* 500KB에 달하는 45개 속성을 위시 리스트 서비스에 반환하는데,이 중 필요한 정보는 200 byte 밖에 안 되는 고객 이름뿐입니다. 이런 형태의 커플링을 스탬프 커플링이라고 합니다. 그럼 필요없는 데이터 교환이 많이 일어나죠 ?

( 계약이 아마 우리가 말하는 api 스펙? 느낌 )

- 프라이빗 REST API 엔드포인트를 둔다.
- 계약에 필드 셀렉터를 사용한다.
- GraphQL 로 계약을분리한다.
- 컨슈머 주도 계약 (CDC), 값 주도 계약 (VDC) 를 병용한다.
- 내부 메시징 엔드포인트를 사용한다.

GraphQL 이야기가 나와서 첨언을 하면, 시작을 할때는 스탬프 커플링을 줄이기 위해서, 하나하나 API 를 뚫다보면, 현타가 온다. 하지만 GraphQL 로 해서 작은 데이터만 가져오면 좋지만, 막상 앱이 커지다 보면 필드가 더 커지고, 반대로 필요한 데이터의 필드를 모두 작성해야 하는 경우가 생기기 시작한다.

CDC 는 E2E 처럼 하는게 아니라 마이크로 서비스의 앞 뒤?? 받기로한 값에 대해서 독립적으로 하는 테스트 방법이다.

VDC도 비슷한거 같아서 ( 비지니스와 값중심이란다. )

**CDC와 VDC의 차이점:**

- *CDC(Consumer Driven Contract)**는 **데이터의 형식과 구조**에 중점을 두고, 서비스 간에 주고받는 데이터가 올바른 형식인지 확인하는 것이 목표야.
- *VDC(Value Driven Contract)**는 데이터 형식뿐만 아니라 **데이터 값 자체가 비즈니스적으로 의미가 있는지**에 중점을 두고, 그 값이 유효한지 확인하는 것이 목적이야.

### **9.2.4** 오류 #4: 네트워크는 안전하다.

![image](https://github.com/user-attachments/assets/772b7bd3-5c51-4b4a-9d2d-421ccfc03675)

여기는 그림만 봐도 한 번에 이해가 가니 길게 설명안하겠다. 진짜 이상한 애들 너무 많다.

모든 엔드포인트에, 서비스 간 통신에도 보안이 적용돼야 하므로 마이크로서비스나 서비스 기반 아키텍처처럼 두 루 분산된 동기 아키텍처에서 당연히 성능이 떨어질 수밖에 없습니다.

### **9.2.5** 오류 #5: 토폴로지는 절대 안 바뀐다.

![image](https://github.com/user-attachments/assets/93363aef-616b-4d8d-9cb1-35e4366628e5)

네트워크를 구성하는 모든 라우터, 허브, 스위치, 방화벽, 네트워크 등 변하지 않을 것이라는 것은 여러분이 회사를 다니면서 불가능하다는 것을 이미 느꼇을 것이다.

아키텍트는 운영자, 네트워크 관리자와 항시 소통을 하면서 무엇이 언제 변경되는지 알고 있어야 합니다.
그래야 앞에서 예시한 당황스러운 사태가 발생해도 적절히 대응할 수가 있습니다.
너무나 뻔하고 쉬운 얘기처럼 들리지만 의외로 만만치 않은 일입니다.
실제로 이 오류는 다음 절의 오류로 직행합니다.

### **9.2.6 오류 #6: 관리자는 한 사람뿐이다**

![image](https://github.com/user-attachments/assets/541a480c-3864-4621-a214-52f43c991548)

아키텍트는 언제나 한 사람의 관리자와만 협의하고 소통하면 된다는 오류에 빠지곤 합니다. 우리 SRE 분들만 해도 한 분이 아니니, 항상 내용이 잘 공유될 수 있도록 노력하자.

### **9.2.7** 오류 #7: 운송비는 0이다

![image](https://github.com/user-attachments/assets/e1546856-3057-41ad-bc16-db5539fefb99)

여기서 운송비는 레이턴시가 아니라, 진짜 cost 를 말하는 것 이다. 

분산 아키텍처는 신규 서브넷, 프록시, 방화벽, 게이트 웨이등 모놀리식 보다 더 많은 돈이 든다.

사실 우리는 와이파이나 전기 같은 것들이 넘치니깐 잘 느끼지 못 하지만, 모이다 보면 사실 작은 비용이 아니다.

### **9.2.8** 오류 #8: 네트워크는 균일하다

![image](https://github.com/user-attachments/assets/b62b4ea7-c653-414b-83b4-e43dc93b4d09)

아키텍트,개발자는 대부분 네트워크가 균일하다고 착각한다.

요는, 온갖 종류의 하드웨어가 서로 다 잘 맞물려 동작하는 건 아니라는 것입니다.

네트워크 표준은 오랜 세월 발전을 해왔으니 큰 문제가 안 될 수도 있겠지만,
모든 상황과 100% 부하 환경에서 완벽하게 테스트를 마친 것은 아니므로 실제로 간혹 네트워크 패킷이 유실되는사고도 심심찮게 일어납니다. ( 앞에 나왔던 레이턴시 같은 이야기도 여기서 발생할 수 있음 )

### **9.2.9** 다른 분산 아키텍처 고려 사항

**분산 로깅**

모놀리식 때는 한곳만 보면되지만, 분산된 구조에서는 각각 가지고 있는 것도 다르고, 포맷마져 다를 수 있다. 그렇기 때문에 유용한 솔루션을 가져오는 것도 좋지만, 그것으로 완벽히 해결할 수는 없다.

이 내용은 너무 심도가 깊기 때문에 이책에서는 다루지 않는다고 합니다.

**분산 트랜잭션**

분산 아키텍처는 최종 일관성(eventual consistency) 이라는 개념을 바탕으로 별도로 분리된 배포 단위
에서 처리된 데이터를 미리 알 수 없는 어느 시점에 모두 일관된 상태로 동기화합니다.

제가 알기로는 NoSQL 데이터베이스들이 이러한 개념을 많이 사용합니다.

**계약 관리 및 버저닝**
