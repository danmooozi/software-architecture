# 아키텍처 스타일 기초

아키텍처 스타일은 아키텍처 패턴이라고도 하며, 다양한 아키텍처 특성을 다루는 컴포넌트 간의 명명된 관계를 기술합니다.  
예를 들어, ‘레이어드 모놀리스’라는 명칭은 구조적 측면과 아키텍처 특성, 배포 모델, 데이터 전략 등을 내포하고 있습니다.  
아키텍처 스타일은 특정 설계 패턴을 가지게 된 이유와 세부 내용을 함축하고 있으며, 이롭거나 해로운 아키텍처 특성들을 전제하고 있습니다.  
아키텍트는 이러한 아키텍처 스타일의 명칭에 익숙해져야 합니다.
2부에서는 다양한 현대 아키텍처 패턴을 다룹니다.

## 9.1 기초패턴

소프트웨어 아키텍처 역사에서 반복적으로 나타나는 패턴들은 코드, 배포, 또는 아키텍처의 다양한 부분을 구성하는 데 도움을 줍니다.  
예를 들어, 레이어 패턴은 기능별로 관심사를 분리하는 오래된 개념으로, 여전히 여러 모습으로 나타나고 있습니다.

### 9.1.1 진흙잡탕(Big Ball of Mud)

**진흙잡탕**은 구조가 없는 애플리케이션 상태를 묘사하는 안티패턴 입니다.  
이 패턴은 내부 구조 없이 데이터베이스를 직접 호출하는 단순한 스크립팅 애플리케이션을 의미하며, 작은 애플리케이션이 커지면서 관리가 어려워지는 상황을 말합니다.  
아키텍트는 이러한 구조 없는 상태를 피해야 하며, 그렇지 않으면 변경, 배포, 테스트, 확장, 성능 관리가 매우 어려워집니다.

진흙잡탕 아키텍처는 의도치 않게 자주 발생하는 안티패턴입니다.  
아키텍트들이 일부러 진흙잡탕을 만들지는 않지만, 코드 품질과 구조에 대한 관리가 부족해 이런 상황이 자주생합니다.  
예를 들어, 한 자바 기반 웹 애플리케이션 프로젝트에서 아키텍처 커플링이 심각한 경우가 있었습니다.  
클래스 간의 연결이 강하게 커플링되어 있어, 클래스 하나의 변경이 다른 클래스에 큰 영향을 미치며, 이로 인해 변경이 매우 어려운 구조였습니다.

### 9.1.2 단일(unitary) 아키텍처

초기 소프트웨어는 단일 컴퓨터에서 실행되었으나, 시간이 지나며 하드웨어와 소프트웨어는 점점 더 정교해지면서 분리되었습니다.  
메인프레임 컴퓨터도 처음에는 단일 시스템이었지만, 점차 데이터를 독립된 시스템으로 분리하게 되었고, PC 네트워크의 확산으로 클라이언트/서버 같은 분산형 시스템이 등장했습니다.  
현재는 임베디드 시스템 등 제약이 많은 환경을 제외하면 단일 시스템은 거의 사용되지 않으며, 성능과 확장성을 유지하려면 시스템의 분리를 통한 관심사의 분리가 필수적입니다.

### 9.1.3 클라이언트/서버

대부분의 아키텍처 스타일은 시스템의 여러 부분을 효과적으로 분리하는 방법에 중점을 둡니다.  
프론트엔드와 백엔드를 분리한 2티어 또는 클라이언트/서버 아키텍처는 이러한 기본적인 아키텍처 스타일의 대표적인 예로, 각 시대의 컴퓨팅 능력에 따라 다양한 형태로 존재해왔습니다.

#### 데스크톱 + 데이터베이스 서버

초기 PC 아키텍처에서는 윈도우 기반의 리치 데스크톱 애플리케이션을 개발되었고, 데이터는 별도의 데이터베이스 서버로 분리되었습니다.  
이 아키텍처는 표준 네트워크 프로토콜을 통해 접속 가능한 standalone 데이터베이스 서버와 잘 맞았습니다.  
프레젠테이션 로직은 데스크톱에서 처리하고, 복잡하고 계산량이 많은 작업은 성능이 좋은 데이터베이스 서버에서 수행하는 방식으로 설계했습니다

#### 브라우저+웹 서버

현대 웹 개발 시대가 오면서, 웹 브라우저가 웹 서버에 접속하고 웹 서버는 다시 데이터베이스 서버에 접속하는 방식의 분리가 일반화되었습니다.  
클라이언트는 데스크톱 대신 가벼운 브라우저로 대체되었고, 방화벽 배포 범위도 확장되었습니다.  
데이터베이스는 웹 서버와 분리되었지만, 두 서버 모두 운영 센터 내부에서 운용되고, 유저 인터페이스는 브라우저에서 실행되므로 여전히 2티어 아키텍처로 간주되기도 합니다.

#### 3티어

1990년대 후반에 인기를 끈 3티어 아키텍처는 더 많은 레이어로 시스템을 분리했습니다.  
자바와 닷넷 진영에서 애플리케이션 서버가 보급되며, 기업들은 **데이터베이스 티어, 애플리케이션 티어, 프런트엔드 티어**로 구성된 구조를 채택했습니다.  
이 3티어 아키텍처는 분산 아키텍처와 잘 맞으며, 공통 객체 요청 브로커 아키텍처(Common Object Request Broker Architecture, CORBA)나 분산 컴포넌트 객체 모델(Distributed Component Object Model, DCOM) 같은 네트워크 수준의 프로토콜과 함께 사용되었습니다.  
오늘날에는 구체적인 네트워크 프로토콜을 신경 쓰지 않고도, 메시지 큐나 이벤트 기반 아키텍처 등의 패턴을 통해 이와 유사한 기능을 구현할 수 있습니다.

## 9.2 모놀리식 대 분산 아키텍처

아키텍처 스타일은 크게 모놀리식과 분산형으로 나뉩니다.  
모놀리식은 전체 코드를 단일 단위로 배포하고, 분산형은 여러 단위로 나눠 원격 액세스 프로토콜을 통해 배포합니다.  
분산 아키텍처는 모놀리식에서는 찾아볼 수 없는 고유한 난제와 이슈를 가지고 있습니다.  
따라서 모놀리식인지 또는 분산형인지를 기준으로 다양한 아키텍처 스타일을 분류하는 것이 의미 있습니다.

**모놀리식**

- 레이어드 아키텍처 (10장)
- 파이프라인 아키텍처 (11장)
- 마이크로커널 아키텍처 (12장)

**분산형**

- 서비스 기반 아키텍처 (13장)
- 이벤트 기반 아키텍처 (14장)
- 공간 기반 아키텍처 (15장)
- 서비스 지향 아키텍처 (16장)
- 마이크로서비스 아키텍처 (17장)

분산 아키텍처는 모놀리식 아키텍처에 비해 성능, 확장성, 가용성 면에서 강력하지만, 큰 트레이드오프가 따릅니다.  
이 오류들은 아키텍처에서 당연하다고 믿거나 전제하지만, 실제로는 틀린 것들을 내포하고 있으며, 오늘날의 분산 아키텍처에서도 여전히 적용됩니다.

### 9.2.1 오류 #1: 네트워크는 믿을 수 있다

개발자와 아키텍트는 네트워크를 신뢰할 수 있다고 가정하지만, 실제로는 그렇지 않습니다.  
분산 아키텍처는 서비스 간의 네트워크에 의존하므로, 서비스 간 통신이 닿지 못하거나, 통신을 보냈는데 응답을 받지 못하는 문제가 발생할 수 있습니다.  
이를 해결하기 위해 타임아웃이나 회로 차단기(circuit braker) 같은 장치를 사용합니다.  
시스템의 네트워크 의존도가 높을수록 시스템의 신뢰도가 낮아질 가능성도 큽니다.

### 9.2.2 오류 #2: 레이턴시는 0이다

로컬 호출의 소요 시간은 나노초에서 밀리초 단위로 측정되지만, 원격 액세스 프로토콜을 통한 호출은 밀리초 단위로 시간이 더 걸립니다.  
따라서 분산 아키텍처에서 레이턴시는 항상 0이 아니며, 이를 무시하면 안 됩니다.  
마이크로서비스처럼 서비스 간 통신이 많은 경우에는 레이턴시가 중요한 성능 요소가 됩니다.  
예를 들어 평균 100 밀리초의 호출 시간이 소요되고, 하나의 비즈니스 로직을 위해 10번의 호출이 필요하다면, 총 소요 시간은 1000밀리초 이상이 됩니다.  
아키텍트는 평균 왕복 레이턴시를 파악해야 하고, 백분위 상 가장 길게 발생하는 long tail 레이턴시가 성능에 큰 영향을 미칠 수 있음을 명심해야 합니다.

### 9.2.3 오류 #3: 대역폭은 무한하다

모놀리식 아키텍처는 대역폭에 큰 영향을 받지 않지만, 마이크로서비스 분산 아키텍처에서는 서비스 간 통신이 대역폭을 많이 점유하게 됩니다.  
이로 인해 네트워크가 느려지면 레이턴시와 신뢰성이 악화됩니다.  
예를 들어, 서비스 A가 위시 리스트를 관리하고, 서비스 B가 고객 프로필을 관리할 때, 서비스 A는 고객 이름을 가져오기 위해 서비스 B를 호출한다고 합시다.  
이 때 로직에서 실제로 필요한 데이터는 200바이트인 반면, 서비스 B는 500KB의 전체 고객 데이터를 전송합니다.  
이를 스탬프 커플링이라고 하며, 이러한 통신이 초당 2,000번 발생하면 대역폭 사용량이 1초에 1GB에 달해 성능에 큰 영향을 미칩니다.

스탬프 커플링을 해결하기 위해 몇 가지 방법을 사용할 수 있습니다.  
분산 아키텍처의 서비스 간에 최소한의 데이터만 주고받도록 하는 것이 최선의 방법입니다.

- 프라이빗 REST API 엔드포인트를 둔다.
- 계약에 필드 셀렉터(field selector)를 사용한다.
- GraphQL로 계약을 분리한다.
- 컨슈머 주도 계약(consumer-driven contract, CDC)과 값 주도 계약(value-driven contract)을 병용한다.
- 내부 메시징 엔드포인트를 사용한다.

### 9.2.4 오류 #4: 네트워크는 안전하다

아키텍트와 개발자는 VPN, trusted network, 방화벽에 익숙해져 네트워크가 항상 안전하지는 않다는 사실을 종종 잊습니다.  
분산 아키텍처에서는 보안이 더욱 어려워집니다.  
분산 아키텍처에서는 모놀리식보다 더 넓은 범위에서 외부 위협에 노출되기 때문에, 분산된 각 엔드포인트는 악의적인 요청이 유입되지 않도록 철저한 보안 대책이 필요합니다.  
이 때 모든 엔드포인트와 서비스 간 통신에 보안을 적용하다 보면, 분산 아키텍처는 성능 저하를 겪을 수밖에 없습니다.

### 9.2.5 오류 #5: 토폴로지는 절대 안 바뀐다

전체 네트워크 토폴로지는 라우터, 허브, 스위치, 방화벽, 네트워크, 어플라이언스 등 다양한 요소로 구성됩니다.  
이러한 네트워크 토폴로지가 변하지 않을 것이라는 가정은 잘못된 생각이며, 네트워크는 항상 변화하고 이 변화가 문제를 일으킬 수 있습니다.  
예를 들어, 월요일 아침에 배포된 서비스가 타임아웃을 일으키는 상황에서, 아키텍트와 팀은 원인을 찾기 위해 고생하다가 네트워크팀이 주말에 작은 업그레이드를 한 것이 문제의 원인임을 발견할 수 있습니다.  
아키텍트는 운영자와 네트워크 관리자와 항시 소통하여 변경 사항을 미리 파악해야 하며, 이를 통해 예기치 못한 문제에 적절히 대응할 수 있어야 합니다.

### 9.2.6 오류 #6: 관리자는 한 사람뿐이다.

아키텍트가 한 명의 관리자와만 소통하면 된다는 생각은 오류입니다.  
대기업에서는 수십 명의 네트워크 관리자가 있기 때문에, 레이턴시나 토폴로지 변경과 관련된 문제를 누구와 상의해야 할지 명확하지 않을 수 있습니다.  
분산 아키텍처는 네트워크 단의 복잡성으로 인해 더 많은 조율이 필요합니다.

### 9.2.7 오류 #7: 운송비는 0이다

여기서 말하는 운송 비용은 레이턴시가 아닌 ‘단순한 REST 호출’에 소요되는 실제 비용을 의미합니다.  
아키텍트가 분산 아키텍처를 도입할 때 필요한 인프라가 충분하다고 잘못 판단하는 경우가 많습니다.  
분산 아키텍처는 모놀리식보다 하드웨어, 서버, 게이트웨이 등 리소스가 더 많이 필요해 비용이 훨씬 많이 듭니다.  
따라서, 분산 아키텍처를 시작하려는 아키텍트는 용량, 대역폭, 레이턴시, 보안 구역 측면에서 서버와 네트워크 토폴로지를 철저히 분석해야 합니다.

### 9.2.8 오류 #8: 네트워크는 균일하다

아키텍트와 개발자는 네트워크가 균일하다고 착각하는 경우가 많지만, 실제로는 여러 업체의 네트워크 하드웨어가 혼재된 환경에서 운영하는 경우가 많습니다.  
다양한 하드웨어가 항상 완벽하게 맞물려 작동하는 것은 아니며, 이로 인해 패킷 유실 같은 문제가 발생할 수 있습니다.  
이는 네트워크 신뢰성, 레이턴시, 대역폭 등에 영향을 미치며, 위에서 살펴본 여러 오류와 혼란을 유발합니다.

### 9.2.9 다른 분산 아키텍처 고려 사항

지금까지 설명한 8가지 오류 외에도, 모놀리식 아키텍처에서는 없지만 분산 아키텍처를 설계할 때 마주하게 되는 여러 문제와 난제들이 있습니다.

#### 분산 로깅

분산 아키텍처에서는 애플리케이션과 시스템 로그가 여러 곳에 분산되어 있어, 데이터 누락의 원인을 찾기가 매우 어렵습니다.  
모놀리식 애플리케이션은 로그가 하나여서 요청을 추적하기 쉬운 반면, 분산 아키텍처에서는 로그가 다양한 종류, 위치, 포맷을 가지기 때문에 문제를 파악하기 어렵습니다.  
스플렁크 같은 로깅 통합 도구를 사용하면 통합된 로그 데이터를 취합할 수 있지만, 복잡한 분산 로그 문제를 완전히 해결하기에는 한계가 있습니다.

#### 분산 트랜잭션

모놀리식 아키텍처에서는 직관적이고 관리가 쉬운 ACID 트랜잭션을 통해 데이터의 일관성과 무결성을 보장합니다.  
(ACID: 원자성 Atomicity, 일관성 Consistency 격리성 Isolation, 지속성 Durability)  
그러나 분산 아키텍처에서는 최종 일관성(eventual consistency) 개념을 기반으로, 데이터가 임의의 시점에 동기화됩니다.  
분산 트랜잭션을 관리하는데 다음의 방법들을 사용할 수 있습니다.

- 트랜잭셔널 사가
  - 이벤트 소싱이나 유한 상태 기계(finite state machine)를 활용해 트랜잭션 상태를 관리하고, 보상을 처리
- BASE 트랜잭션
  - (BA)sic availability(기본 가용성), (S)oft state(소프트 상태), (E)ventual consistency (최종 일관성)
  - 소프트웨어 조각이 아니라 일종의 기법을 의미
  - 소프트 상태는 소스에서 타깃으로의 데이터 전달과 데이터 소스 간의 비일관성을 나타내며, 시스템은 결국 메시징과 아키텍처 패턴을 통해 일관성을 유지하게 됨

#### 계약 관리 및 버저닝

계약은 클라이언트와 서비스 간의 합의된 행위와 데이터를 의미합니다.  
분산 아키텍처에서는 각 서비스와 시스템이 다른 팀이나 부서에 의해 관리되기 때문에, 계약을 유지보수 하기가 특히 어렵습니다.