# 11. 파이프라인 아키텍처 스타일

- 기본적인 아키텍처 스타일
- 개발자와 아키텍트가 기능을 개별 파트로 분리하기로 결정하는 순간부터 이 패턴이 수반
- Bash나 Zsh 같은 유닉스 터미널 쉘 언어의 기초 원리
- 함수형 언어 개발자는 언어 구조와 이 아키텍처 요소가 유사하다고 생각
- 맵리듀스 프로그래밍 모델을 응용한 많은 도구가 이 기본 토폴로지를 따른다.
    - MapReduce: 대규모 데이터 처리를 위한 프로그래밍 모델로, 'Map' 단계와 'Reduce' 단계로 구성.
    - Map 단계 : 데이터를 변환하는 역할을 하며, 이는 파이프라인의 변환기(transformer) 필터와 유사.
    - Reduce 단계 : 변환된 데이터를 집계하는 역할을 하며, 이는 파이프라인의 테스터(tester) 필터와 유사한 개념.

## 11.1 토폴로지

- 파이프라인 아키텍처는 다수의 **파이프**와 **필터**로 구성.
    <img width="671" alt="스크린샷 2024-11-03 오후 8 40 31" src="https://github.com/user-attachments/assets/936b628b-5241-4af4-89bf-b8372348e8db">

- 단방향 통신
- 점대점 방식
    - 두 노드 간에 직접적이고 독립적으로 연결을 제공하는 네트워크 구성 방식

### 11.1.1 파이프

- 한 소스에서 입력을 받아 다른 소스로 출력을 내는, 필터 간 통신 채널
- 파이프는 성능상 이유로 보통 단방향, 점대점 방식으로 구성
- 페이로드의 데이터는 어떤 포맷이라도 가능, 아키텍트는 고성능에 유리한 적은 양의 데이터를 선호

### 11.1.2 필터

- 자기 완비형
    - 독립적으로 작동 가능
- 일반적으로 무상태성
    - 이전의 작업의 결과나 상태를 저장하지 않는다.
    - 이전 작업의 영향을 받지 않는다.

### 필터의 네 가지 종류

**프로듀서**

- 프로세스의 시작점
- 아웃바운드만 있어서 소스라고도 불린다.
    - 들어오는 트래픽 없고 나가는 트래픽만 있다.

**변환기**

- 입력을 받아 데이터 변환
- 그 결과를 아웃바운드 파이프로 전달
- 맵

**테스터**

- 입력을 받아 하나 이상의 기준에 대해 테스트
- 결과에 따라 필요시 결과를 생산
- 리듀스

**컨슈머**

- 파이프라인 흐름의 종착역
- 프로세스의 최종 결과를 데이터베이스에 저장하거나 유저 인터페이스 화면에 표시

**예제**

- 어떤 텍스트 파일을 일고 가장 출현 빈도가 높은 단어 n개를 찾아 빈도 순으로 정렬한 결과를 출력하는 프로그램

```jsx
tr -cs A-Za-z ‘\n tr A-Z a-z |
sort |
uniq -c |
sort -rn | sed ${l}q
```

- **`tr -cs A-Za-z '\n'`**: `tr` 명령어는 텍스트를 변환하는 데 사용됩니다. `cs` 옵션은 문자 세트를 반전시켜 일치하지 않는 문자(공백이나 특수 문자 등)를 줄 바꿈(`\n`) 문자로 변환합니다. 여기서는 알파벳(A-Z, a-z) 이외의 모든 문자를 줄 바꿈으로 대체하여 단어들을 분리합니다.
- **`tr A-Z a-z`**: 대문자를 소문자로 변환하여 대소문자 구분 없이 단어를 비교할 수 있도록 만듭니다.
- **`sort`**: 텍스트의 모든 줄을 알파벳 순서로 정렬합니다. 이때 각 줄은 하나의 단어로 구성됩니다.
- **`uniq -c`**: 정렬된 단어 리스트에서 중복되는 단어를 카운팅합니다. `c` 옵션은 각 단어의 빈도 수를 함께 출력합니다.
- **`sort -rn`**: `uniq -c`로 얻은 빈도 수를 내림차순(-r)으로 정렬하여, 가장 빈도수가 높은 단어가 먼저 나오도록 합니다. `n` 옵션은 숫자로 정렬하게 만듭니다.
- **`sed ${l}q`**: `sed`는 스트림 편집기로 텍스트를 변형할 수 있는 명령어입니다. `${l}`은 스크립트에 정의된 변수로, 출력할 단어의 개수를 지정합니다. 예를 들어 `l=10`이라면 상위 10개의 단어만 출력됩니다. `q`는 해당 숫자만큼 출력 후 종료하게 만듭니다.

## 11.2 예제

- EDI
    - 전자 데이터 교환 도구
    - 파이프와 필터로 한 종류의 문서를 다른 종류의 문서로 변환
- ETL
    - 추출, 변환, 적재 도구
    - 다른 데이터베이스나 데이터소스로 데이터를 변환
- **아파치 카멜**
    - 여러 시스템 간에 데이터를 쉽게 전달하고 통합하는 역할
- **오케스트레이터**
    - 워크플로우와 프로세스를 관리
    - 각각의 서비스가 어느 순서로 호출되어야 하는지, 어떤 데이터가 필요하고 어디로 보내져야 하는지 등을 결정
- **중재자**
    - 각각의 서비스가 직접적으로 서로를 호출하지 않고, 중재자를 통해 데이터를 주고 받도록 하는 구조
    

### 다양한 서비스의 텔레메트리 정보를 아파치 카프카에 스트리밍하는 예제

- 텔레메트리 정보
    - 원격 시스템에서 수집한 상태, 성능, 이벤트 관련 데이터를 의미
<img width="703" alt="스크린샷 2024-11-03 오후 8 40 44" src="https://github.com/user-attachments/assets/75afc817-fca0-4864-956c-12ca5a09d6d4">

1. 서비스 정보 캡쳐
- 카프카 토픽을 구독하여 서비스 정보를 받아 이 데이터를 지속 시간 필터라는 테스터 필터에 보내고 카프카에서 받아온 데이터가 서비스 요청 지속 시간과 연관되어 있는지 판단.
- 카프카 토픽에 연결하는 일만 신경을 쓴다.

2. 지속 시간 필터
- 데이터 검증 후 필요시 다음 파이프에 보내는 작업만 한다.
- 만약 데이터가 서비스 요청 지속 시간과 관련이 있으면 지속 시간 필터는 이 데이터를 지속 시간 계산기 필터로 전달하고, 관련이 없으면 가동 시간 필터로 보내 데이터가 가동 시간 메트릭과 관련 있는지 체크
- 만약 없으면 해당 데이터는 이 특정한 처리 흐름에 아무 쓸모가 없으므로 파이프라인은 즉시 종료
- 반대로, 관련이 있으면, 가동 시간 계산기 필터로 보내 해당 서비스의 가동 시간 메트릭을 계산

3. 변환기
- 두 변환기는 수정된 데이터를 데이터베이스 출력 컨슈머로 보내 몽고 DB에 저장.

## 11.3 아키텍처 특성 등급

- 파이프라인 아키텍처 스타일은 애플리케이션 로직을 필터 타입에 따라 나누는, 기술 분할 아키텍처
- 보통 모놀리식 형태로 구현/배포하므로 아키텍처 퀀텀은 언제나 1
    - 모놀리식 배포 탓에, 또 부족한 아키텍처 모듈성 때문에 내고장성도 별로
        - 어느 한 작은 파트에 OOM이 발생하면 애플리케이션 전체적으로 영향을 받고 충돌이 발생
