# 파이프라인 아키텍처 스타일

파이프라인 아키텍처(Pipeline Architecture)는 소프트웨어 아키텍처에서 기본적인 스타일로, 기능을 개별 파트로 분리할 때 기본적으로 사용됩니다.  
Bash 같은 유닉스 터미널 쉘 언어나 함수형 언어의 맵리듀스(MapReduce) 모델도 이 아키텍처를 따릅니다.  
이 아키텍처는 저수준의 구현부터 고수준의 비즈니스 애플리케이션 구조에까지 폭넓게 적용될 수 있습니다.

## 11.1 토폴로지

파이프라인 아키텍처는 다수의 파이프와 필터로 구성됩니다.

### 11.1.1 파이프

파이프는 필터 간 통신 채널로, 한 소스에서 입력을 받아 다른 소스로 출력을 냅니다.  
성능을 위해 파이프들은 보통 단방향, 점대점 방식으로 구성되며, 파이프를 오가는 페이로드는 적은 양의 데이터로 구성하는 것이 권장됩니다.

### 11.1.2 필터

필터는 자기 충족형(self-contained)으로 독립적인 단위이며, 일반적으로 무상태성을 유지합니다.  
파이프라인 아키텍처에서 필터는 한 가지 태스크만 처리하며, 복합적인 태스크는 여러 필터를 연결하여 처리합니다.  
각 파이프와 필터는 단방향으로 단순하게 동작하기 때문에 다양한 조합이 가능합니다.

필터의 네 가지 종류는 다음과 같습니다:

1. **프로듀서(Producer)**: 프로세스의 시작점으로, 들어오는 인바운드 트래픽 없이 아웃바운드 트래픽만 처리하는 source 역할을 합니다.
2. **변환기(Transformer)**: 입력을 받아 데이터를 변환하고, 결과를 아웃바운드 파이프로 전달합니다. (map)
3. **테스터(Tester)**: 입력을 테스트하여 기준에 따라 결과를 생성합니다. (reduce)
4. **컨슈머(Consumer)**: 파이프라인의 종착역으로, 최종 결과를 저장하거나 화면에 표시합니다.

## 11.2 예제

파이프라인 아키텍처 패턴은 간단한 단방향 처리 작업에 자주 사용됩니다.  
예를 들어, 전자 데이터 교환(EDI, electronic data interchange) 도구는 파이프와 필터를 통해 문서를 다른 종류로 변환하며, ETL(Extract/Transform/Load, 추출/변환/적재)도구도 데이터를 변환하고 이동시킬 때 파이프라인 아키텍처를 사용합니다.  
또한, Apache Camel 같은 오케스트레이터 및 중재자어플리케이션도 파이프라인 아키텍처를 기반으로 다음의 비즈니스 단계로 정보를 전달합니다.

또 하나의 예제는 파이프라인 아키텍처를 사용해 다양한 서비스의 텔레메트리 정보를 아파치 카프카에 스트리밍 처리하는 방식입니다.  
**서비스 정보 캡처 필터(프로듀서)**는 카프카 토픽을 구독하고, **지속 시간 필터(테스터)**는 이 데이터를 검증해 관련된 데이터를 다음 단계로 보냅니다.  
지속 시간과 관련 있으면 **지속 시간 계산기 필터(변환기)**로 데이터가 전달되어 지속시간 관련 메트릭이 계산됩니다.
지속 시간과 관련이 없으면 **가동 시간 필터(테스터)**로 보내고, 해당 데이터가 가동 시간과 관련이 없으면 파이프라인은 종료됩니다.  
관련이 있으면 **가동 시간 계산기 필터(변환기)**로 데이터가 전달 되어 가동시간 메트릭이 계산됩니다.  
두 변환기는 **최종 데이터를 몽고DB에 저장**합니다.

이 예제는 파이프라인 아키텍처의 확장성을 보여줍니다.  
예를 들어, 새로운 메트릭인 데이터베이스 접속 대기 시간을 처리하려면, **가동 시간 필터 뒤에 테스트 필터를 추가하는 방식으로 간단히 확장**할 수 있습니다.

## 11.3 아키텍처 특성 등급

| 아키텍처 특성 | 별점      |
| ------------- | --------- |
| 퀀텀 수       | 1         |
| 배포성        | X         |
| 탄력성        | X         |
| 진화성        | X         |
| 내고장성      | X         |
| 모듈성        | X         |
| 전체 비용     | X X X X X |
| 성능          | X X       |
| 신뢰성        | X X X     |
| 확장성        | X         |
| 단순성        | X X X X X |
| 시험성        | X X       |

파이프라인 아키텍처는 보통 모놀리식 형태로 구현되고, 아키텍처 퀀텀은 1입니다.  
주요 강점은 모듈성과 관련된 비용 절감과 단순성입니다.  
복잡도가 적고 유지보수 비용이 적으며, 필터 간의 관심사 분리를 통해 모듈성을 확보해 필터를 수정해도 다른 필터에 영향을 주지 않습니다.

파이프라인 아키텍처는 필터를 통한 모듈성 덕분에 레이어드 아키텍처보다 배포성과 시험성이 조금 더 나은 편입니다.  
하지만 여전히 모놀리식 구조이기 때문에 절차, 배포 빈도, 테스트 완성도에 따라 리스크가 커질 수 있습니다.  
모놀리식 특성 상 조금만 변경할 일이 생겨도 전체 모놀리스를 테스트 및 배포해야 하기 때문에 배포성이 좋지 않습니다.  
분산 아키텍처에 비해 네트워크 문제는 없기 때문에 신뢰성이 괜찮지만, 낮은 배포성과 시험성 때문에 신뢰성은 중간 수준(별점 3개)입니다.

파이프라인 아키텍처는 모놀리식 배포로 인해 탄력성과 확장성이 낮으며, 이를 확장하려면 멀티스레딩과 같은 복잡한 기법이 필요합니다.  
이 아키텍처는 단일 시스템 퀀텀으로 특정 지점까지만 확장 가능합니다.  
또한 모놀리식 구조로 인해 내고장성도 낮으며, 일부 시스템에서 작은 문제(OOM 등)가 발생해도 애플리케이션 전체에 영향을 미칩니다.  
MTTR이 길어 소규모 애플리케이션은 2분, 대규모는 15분 이상의 시동 시간이 필요해 가용성에도 악영향을 줍니다.