# 레이어드 아키텍처

레이어드 아키텍처(Layered Architecture 또는 n-티어 아키텍처)는 가장 흔하고 비용 효율적인 아키텍처 스타일로, 대부분의 애플리케이션에 표준으로 사용됩니다.  
레이어드 아키텍처는 콘웨이의 법칙에 따라 조직의 계층 구조와 맞아떨어져 자연스럽게 많이 사용되며, UI 개발자, 백엔드 개발자, 규칙 개발자, 데이터베이스 전문가(DBA)와 같은 역할이 명확히 구분됩니다.  
개발자가 명확한 아키텍처 스타일을 결정하지 못했을 때, 특히 애자일 방식에서 레이어드 아키텍처는 일반적으로 적합한 선택이 될 수 있습니다.

## 10.1 토폴로지

레이어드 아키텍처에서는 내부 컴포넌트가 수평적인 레이어들로 구성되며, 각 레이어는 애플리케이션에서 특정 역할(프레젠테이션 로직, 비즈니스 로직 등)을 수행합니다.  
레이어의 개수와 유형에는 제한이 없지만, 일반적으로 **프레젠테이션, 비즈니스, 퍼시스턴스, 데이터베이스**의 4가지 표준 레이어로 구성됩니다.  
복잡한 비즈니스 애플리케이션은 5개 이상의 레이어로 구성될 수 있으며, 퍼시스턴스 로직이 비즈니스 레이어에 포함될 경우 두 레이어를 병합할 수도 있습니다.

이러한 물리적 계층을 배포 관점에서 다양한 토폴로지로 변형할 수 있습니다.  
첫 번째 그림에서는 프레젠테이션, 비즈니스, 퍼시스턴스 레이어가 하나의 배포 단위로 합쳐지고, 데이터베이스 레이어는 외부에 분리됩니다.  
두 번째 그림은 프레젠테이션 레이어를 별도의 배포 단위로 분리하고, 비즈니스와 퍼시스턴스 레이어는 함께 배포됩니다.  
마지막 그림에서는 모든 레이어가 하나의 배포 단위로 묶여 있으며, 이는 인메모리 데이터베이스를 사용하는 소규모 애플리케이션에 적합합니다.

<img src="./images/10-2.png" alt="레이어드 아키텍처" width="600"/>

레이어드 아키텍처에서 각 레이어는 특정 역할을 수행합니다.  
프레젠테이션 레이어는 사용자 인터페이스와 브라우저 통신을 처리하고, 비즈니스 레이어는 요청에 따라 비즈니스 규칙을 실행하며, 퍼시스턴스 레이어는 데이터를 제공합니다.  
각 레이어는 자신의 역할에 집중하며, 다른 레이어의 세부 사항에는 관여하지 않습니다.  
예를 들어, 프레젠테이션 레이어는 데이터 조회 방법을 알 필요가 없으며, 비즈니스 레이어는 데이터를 어디서 가져오는지나 화면 표시 방식에 관여하지 않습니다.

레이어드 아키텍처는 관심사의 분리를 통해 각 레이어의 역할과 책임을 명확히 구분합니다.  
각 레이어의 컴포넌트는 해당 레이어에 맞는 로직만 처리하며, 각 영역의 개발자는 도메인의 특정 기술 영역에 집중할 수 있습니다.  
하지만 레이어드 아키텍처는 전체적인 민첩성이 떨어져 변화에 신속하게 대응하는 능력이 제한될 수 있다는 트레이드오프가 있습니다.  
또한 레이어드 아키텍처에서는 하나의 비즈니스 도메인(예: ‘고객’)이 여러 레이어에 분산되어, 도메인에 대한 변경이 복잡해집니다.  
이러한 특성 때문에 도메인 주도 설계 방식과는 잘 맞지 않습니다.

## 10.2 레이어 격리

레이어드 아키텍처에서 각 레이어는 폐쇄 또는 개방 상태 입니다.  
폐쇄 레이어는 요청이 상위 레이어에서 하위 레이어로 순차적으로 이동해야 하며, 중간 레이어를 건너뛸 수 없습니다.  
즉, 요청이 프레젠테이션 레이어에서 시작되면 비즈니스, 퍼시스턴스 레이어를 차례로 거쳐 최종적으로 데이터베이스 레이어에 도달합니다.
하지만 단순 조회 요청의 경우, 프레젠테이션 레이어가 데이터베이스를 직접 액세스하면 더 빠를 수 있습니다.  
이를 위해서는 비즈니스와 퍼시스턴스 레이어가 개방되어 있어야 하는데, “**레이어 격리**”라는 개념을 통해 폐쇄 레이어와 개방 레이어 중 어느 것이 더 나은지 알 수 있습니다.

레이어 격리는 **한 레이어에서의 변경이 다른 레이어에 영향을 미치지 않도록 보장**하는 개념으로, 각 레이어는 독립적으로 작동하며 서로의 내부 로직을 알지 못해야 합니다.  
이를 위해 메인 요청 흐름의 레이어는 폐쇄되어 있어야 합니다.  
만약 프레젠테이션 레이어가 퍼시스턴스 레이어에 직접 액세스하면, 퍼시스턴트 레이어의 변경 시 프레젠테이션 레이어도 함께 영향을 받게 되어 레이어의 상호 의존도가 높아집니다.  
이로 인해 변경과 유지보수가 어렵고 비용이 많이 들게 됩니다.  
레이어를 잘 격리하면 다른 레이어에 영향을 주지 않고 각 레이어를 교체하는 것이 가능합니다.

## 10.3 레이어 추가

아키텍처에서 폐쇄 레이어를 통해 변경을 격리할 수 있지만, 특정 레이어는 개방하는 것이 더 적합한 경우도 있습니다.  
예를 들어, 비즈니스 레이어에서 각 로직들이 공통으로 사용해야 하는 기능(날짜, 문자열 유틸리티, 감사, 로깅 클래스 등)들이 있다고 합시다.  
만약 해당 기능을 담당하는 공유 객체를 비즈니스 레이어에 두게 되면, 프레젠테이션 레이어가 이를 엑세스할 수 있는 구조가 되어 통제하기 어려운 아키텍처가 됩니다.

프레젠테이션 레이어가 비즈니스 레이어의 공유 객체를 액세스하지 못하도록 하기 위해서는, 공유 객체를 포함한 새로운 서비스 레이어를 추가할 수 있습니다.  
해당 서비스 레이어는 비즈니스 레이어와 퍼시스턴스 레이어 사이에 추가합니다.  
이 때 비즈니스 레이어가 퍼시스턴스 레이어에 바로 접근하는 것도 가능해야 하기 때문에, 새로 추가된 서비스 레이어는 개방 레이어로 설계됩니다.  
이를 통해 비즈니스 레이어는 폐쇄 상태로 유지되고, 프레젠테이션 레이어는 공유 객체를 직접 사용할 수 없게 되면서, 동시에 비즈니스 레이어는 서비스 레이어를 거쳐 다른 레이어로 이동할 수 있게 됩니다.

개방/폐쇄 레이어 개념을 활용하면 아키텍처 레이어 간 관계와 요청 흐름을 명확히 정의하고, 개발자에게 액세스 제약과 관련해서 명확하게 정보를 제공할 수 있습니다.

## 10.4 기타 고려 사항

아키텍처 스타일을 결정하지 못했다면, 레이어드 아키텍처는 좋은 출발점이 될 수 있습니다.  
레이어드 아키텍처는 재사용을 최소화하고 객체 계층을 가볍게 유지해 모듈성을 확보하는데 도움을 주기 때문에, 나중에 다른 아키텍처로 전환할 때도 큰 어려움이 없습니다.

다만 레이어드 아키텍처를 사용할 때에는 싱크홀 안티패턴을 조심해야 합니다.  
**아키텍처 싱크홀 안티패턴**은 요청이 각 레이어를 통과할 때 비즈니스 로직이 추가되지 않은 채로 단순히 전달만 되는 문제를 말합니다.  
예를 들어, 고객 데이터를 조회하는 요청이 프레젠테이션, 비즈니스, 규칙, 퍼시스턴스 레이어를 거치면서 단순 전달만 되고, 내부에거 SQL 조회만 수행되어 반환되는 상황입니다.  
이로 인해 각 레이어를 거치면서 불필요한 객체 초기화와 메모리 사용이 발생하여 성능이 저하될 수 있습니다.  
싱크홀 안티패턴을 완전히 피하기는 어렵지만, 전체 요청의 20% 정도만 해당된다면 허용 가능한 수준입니다.  
그러나 80% 이상의 요청이 싱크홀이라면, 레이어드 아키텍처가 문제 도메인에 적합하지 않다는 신호입니다.  
이를 해결하기 위해 레이어를 개방하는 방법도 있지만, 이는 변경 관리를 어렵게 만들 수 있습니다.

## 10.5 왜 이 아키텍처 스타일을 사용하는가

레이어드 아키텍처는 작고 단순한 애플리케이션이나 웹사이트에 적합하며, 예산과 일정이 빠듯할 때 초기 아키텍처로 채택하면 좋습니다.  
레이어드 아키텍처는 개발자들에게 익숙하고 복잡하지 않아 소규모 애플리케이션을 쉽게 개발할 수 있습니다.  
그러나 애플리케이션 규모가 커지면 유지 보수성, 민첩성, 시험성, 배포성 등이 점점 나빠지므로, 대규모 시스템에는 더 모듈화된 아키텍처를 채택해야 합니다.

## 10.6 아키텍처 특성 등급

| 아키텍처 특성 | 별점      |
| ------------- | --------- |
| 퀀텀 수       | 1         |
| 배포성        | X         |
| 탄력성        | X         |
| 진화성        | X         |
| 내고장성      | X         |
| 모듈성        | X         |
| 전체 비용     | X X X X X |
| 성능          | X X       |
| 신뢰성        | X X X     |
| 확장성        | X         |
| 단순성        | X X X X X |
| 시험성        | X X       |

레이어드 아키텍처는 비용 절감과 단순성이 강점이며, 모놀리식 구조에 가깝기 때문에 분산 아키텍처에 비해 복잡도가 낮고 유지보수 비용도 적습니다.  
하지만 애플리케이션이 커질수록 이러한 장점이 사라집니다.  
레이어드 아키텍처는 배포성과 시험성이 낮은데, 배포 시 리스크가 크고 절차가 복잡해 자주 배포하기 어렵습니다.  
작은 코드 변경에도 전체 시스템을 다시 배포해야 하고, 여러 레이어의 변경 사항이 함께 적용되면서 배포 리스크가 커집니다.  
시험성이 낮은 이유도 동일하며, 작은 변경이라는 이유로 전체 회귀 테스트를 실행하지 않거나, 동시에 수십 가지의 변경 사항을 반영하는 경우 리스크는 커집니다.  
하지만 컴포넌트나 레이어를 모킹하거나 스터빙할 수 있기 때문에 테스트하기에 용이한 부분도 있습니다.

또한 모놀리식 구조로 인해 모듈성이 부족해 탄력성과 확장성도 낮게 평가됩니다.  
레이어드 아키텍처는 유저 인터페이스, 백엔드, 데이터베이스가 단일 시스템 퀀텀에 기반하기 때문에, 특정 지점까지만 확장할 수 있습니다.
또한 성능 측면에서도 병렬 처리 부족과 싱크홀 안티패턴 등으로 인해 레이어드 아키텍처는 고성능 시스템에 적합하지 않습니다.

또한 레이어드 아키텍처는 모놀리식 배포와 부족한 모듈성으로 인해 내고장성이 낮습니다.  
메모리 부족(OOM) 문제가 발생하면 애플리케이션 전체에 영향을 미쳐 충돌을 일으킬 수 있습니다.  
또한 평균 수리 시간(MTTR, Mean-Time-To-Recovery)이 길어, 소규모 애플리케이션은 2분, 대규모 애플리케이션은 15분 이상의 시동 시간이 소요되어 가용성에도 부정적인 영향을 줍니다.