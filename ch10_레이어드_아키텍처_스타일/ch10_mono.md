# 10. 레이어드 아키텍처 스타일

가장 흔한 아키텍처 스타일 중 하나입니다.

단순하고 대중적이면서 비용도 적게 들어 모든 애플리케이션의 사실상 표준입니다.

아키텍트가 어떤 아키텍처 스타일을 사용하는 게 좋을지 확신이 없거나 애자일 개발팀이 ‘일단 코딩을 시작’해보기로 했다면 레이어드 아키텍처는좋은 선택지가 될 가능성이 높습니다.

## **10.1** 토폴로지

레이어드 아키텍처에서 내부 컴포넌트는 논리적으로 수평한 레이어들로 구성되며, 각 레이어는 애플리케이션에서 （프레젠테이션 로직, 비즈니스 로직 등의） 주어진 역할을 수행합니다.

보통 규모가 작은 애플리케이션 3개 ,덩치가 크고 복잡한 비즈니스 애플리케이션은 5 개 또는 그 이상의 레이어로 구성됩니다.

레이어드 아키텍처 스타일의 각 레이어는 아키텍처 내부에서 특정한 역할과 임무를 수행합니다.

관심사의 분리 개념 덕분에 레이어드 아키텍처 스타일은 아키텍처 내부의 역할 및 책임 모델을 효과적으로 구성할 수 있습니다.

‘고객’도메인은 프레젠테이션,비즈니스,서비스,데이터베이스 모든 레이어에 다 포함되므로 이 도메인에 어떤 변경을 가하는 일이 쉽지 않습니다. 이런 이유로 아키텍처 스타일은 도메인 주도 설계 방식과는 잘 안 맞습니다

## **10.2** 레이어 격리

저는 이게 레이어드 아키텍처의 제일 중요한 개념이라고 생각합니다.

레이어드 아키텍처의 각 레이어는 폐쇄 또는 개방 상태입니다. 요청이 상위 레이어에서 하위 레이어로 이동하므로 중간의 어떤 레이어도 건너뛸 수 없고 현재레이어를 거쳐야 바로 그 다음 레이어로 나아갈 수 있다는 뜻입니다.

순 조회 요청이라면 불필요한 레이어를 건너뛰고 프레젠테이션 레이어가 데이터베이스를 직접 액세스하는 편이 더 빠르고 간편할 것입니다（2000년대 초반에는 이를 추월 차선 리더 패턴이라고 했습니다）

레이어 격리는 어느 아키텍처 레이어에서 변경이 일어나도 다른 레이어에 있는 컴포넌트에 아무런 영향을 끼치지 않기에 레이어 간 계약은 불변임을 의미합니다.
각 레이어는 서로 독립적으로 작동되므로 다른 레이어의 내부 작동 로직은 거의/전혀 알지 못합니다.

## **10.3** 레이어 추가

아키텍처 내부적으로 폐쇄 레이어를 이용해 변경을 격리할 수 있지만, 어떤 레이어는 개방하는 것이 더 합리적인 경우도 있습니다.

개방/폐쇄 레이어 개념을 잘 활용하면 아키텍처 레이어 간 관계와 요청 흐름을 정의할 때 유용합니다. 또 개발자에게 아키텍처 내부의 다양한 레이어 액세스 제약에 관한 필수 정보와 지침을 제공할 수 있습니다.

## **10.4** 기타 고려 사항

레이어드 아키텍처에서는 아키텍처 싱크홀 안티패턴을 조심해야 합니다. 요청이 한 레이어에서 다른 레이어로 이동할 때 각 레이어가 아무 비즈니스 로직도 처리하지 않고 그냥 통과시키는 안티패턴을 말합니다.

이런 흐름은 불필요한 객체 초기화 및 처리를 빈번하게 유발하고 쓸데없이 메모리를 소모하며 성능에도 부정적인 영향을 끼칩니다.

아키텍처 싱크홀 안티패턴에 해당하는 시나리오가 전무한 레이어드 아키텍처는 아마 하나도 없을 것입니다.

그러므로 이 안티패턴으로 처리 중인 요청의 전체 비율을 따져보는 것이 중요합니다. ( 80:20 정도 )

## **10.5** 왜 이 아키텍처 스타일을 사용하는가

레이어드 아키텍처는 작고 단순한 애플리케이션이나 웹사이트에 알맞은 아키텍처 스타일입니다. 특히, 처음 구축을 시작할 때, 예산과 일정이 빠듯한 경우 출발점으로 괜찮은 아키텍처 선택입니다. 

레이어드 아키텍처 기반의 애플리케이션은 규모가 커질수록 유지 보수성,민첩성,시험성,배포성 같은 아키텍처 특성이 점점 나빠집니다

## **10.6** 아키텍처 특성 등급

전체 비용과 단순성은 레이어드 아키텍처 스타일의 주요 강점입니다.이 아키텍처는 원래 모놀리식에 가깝기 때문에 분산 아키텍처 스타일에 따른 복잡도가 낮고, 구조가 단순해서 알기 쉬운 데다 구축 및 유지보수 비용도 비교적 적게 듭니다.
그러나 모놀리식 레이어드 아키텍처가 점점 커지고 결과적으로 더 복잡해질수록 이런 장점들도 빛을 바랜다는 사실에 유의해야 합니다.
