# 14. 이벤트 기반 아키텍처 스타일

이벤트 기반 아키텍처는 확장성이 뛰어난 고성능 애플리케이션 개발에 널리  쓰이는 비동기 분산 아키텍처 스타일입니다.

애플리케이션은 대부분요청 기반 모델을 따릅니다. 이 모델에서는 어떤 액션을 수행하도록 시스템에 요청하면 요청 오케스트레이터가 접수합니다.

요청 오케스트레이터는 보통 유저 인터페이스이지만 **API** 레이어나 엔터프라이즈 서비스버스로도 구현할 수 있습니다

![image](https://github.com/user-attachments/assets/0893735d-5337-4a4a-beb0-35a49549f27b)


이벤트 기반 모델은 특정한 상황에 대응하여 그 이벤트에 알맞게 액션을 취합니다. 예를 들어, 온라인 경매 사이트에서 입찰자가 어떤 품목에 입찰을 한다고 합시다. 입찰을 하는 행위는 시스템에 뭔가 요청을 하는 것으로 볼 수도 있지만, 현재 가격이 발표된 직후에 발생하는 이벤트에 더 가깝습니다. 시스템은 이 이벤트에 반응함으로써 동시 발생한 다른 입찰가와 비교후 현재까지 누가 가장 높은 가격을 부른 입찰자인지 결정합니다.

## **14.1** 토폴로지

이벤트 기반 아키 텍처의 주요 토폴로지는 중재자 토폴로지와 브로커 토폴로지 입니다. (  입습니다. 라는 오타가 있다. ) 주로 중재자 토폴로지는 이벤트 처리 워크플로를 제어해야 할 경우에, 브로커 토폴로지는 신속한 응답과 동적인 이벤트 처리 제어가 필요할 때 각각 사용됩니다. 두 토폴로지의 아키텍처 특성과 구현 전략은 서로 다르기 때문에 주어진 상황에 가장 알맞은 것을 선택하려면 각각의 특징을 정확하게 이해해야 합니다.

## **14.2** 브로커 토폴로지

브로커 토폴로지는 중앙에 이벤트 중재자가 없다는 점에서 중재자 토폴로지와 다릅니다. 메시지는 （RabbitMQ, ActiveMQ, HornetQ 등의） 경량 메시지 브로커를 통해 브로드캐스팅되는 식으로 이벤트 프로세서 컴포넌트에 분산되어 흘러갑니다.

![image](https://github.com/user-attachments/assets/d0aa94a1-2458-4b90-aeb9-784a26a2736c)

브로커 토폴로지는 네 가지 기본 아키텍처 컴포넌트

- 시작 이벤트
    - 이벤트 흐름을 개시하는 이벤트
    - 이벤트 브로커의 이벤트 채널로 전송되어 처리됩니다
- 이벤트 브로커
    - 시작 이벤트를 받자마자 관련된 처리 작업
    - 이벤트 브로커 컴포넌트는 보통 연합체（도메인 기반으로 클러스터링된 다수의 인스턴스）로 구성
    - 도메인의 이벤트 흐름에서 사용되는 모든 이벤트 채널을 가짐
    - 발행 구독 메시징 모델
- 이벤트 프로세서
    - 처리 이벤트를 리스닝하고 있다가 이벤트가 들어오면 그에 맞는 작업을 수행한 뒤 다시 새로운 처리 이벤트를 발행함
    - 최종 이벤트 프로세서가 한 일에 아무도관심이 없을때까지 되풀이됩니다
    - 다른 이벤트 프로세서의 관심 여부와 무관하게 각 이벤트 프로세서가 자신이 한 일을 모두에게 알리는 게 항상 바람직합니다.
- 처리 이벤트
    - 필요시 부가적인 처리를 위해 이벤트 브로커에 비동기 전송

브로커 토폴로지는 릴레이 경주 같다고 생각하면 이해가 빠릅니다. 릴레이 경주는 주자가 바통을 들고 정해진 거리를 달리고 다음 주자에게 바통을 넘겨주는 식으로 마지막 주자가 결승선을 통과할 때까지 정해진 순번에 따라 진행됩니다.

브로커 토폴로지도 비슷합니다. 이벤트 프로세서는 이벤트 전달 후 더 이상 그 이벤트 처리에는 관여하지 않고 다른 시작 이벤트 또는 처리 이벤트에 반응할 준비를 합니다. 또한 각 이벤트 프로세서는 이벤트 처리 도중 가변적인 부하나 백업 조건을 처리하기 위해 서로 독립적으로 확장할 수 있습니다. 만약 어떤 환경 문제로 인해 이벤트 프로세서가 느려지거나 실패하면 그 프로세서가 구독하는 토픽이 배압 지점이 됩니다.

![image](https://github.com/user-attachments/assets/941a2b2f-c3df-4698-9397-a37603ee5ce4)


## **14.3** 중재자 토폴로지

중재자 토폴로지는 좀 전에 살펴본 브로커 토폴로지의 단점들을 일부 보완합니다. 여러 이벤트 프로세서 간의 조정이 필요한 시작 이벤트에 대하여 워크플로를 관리/ 제어하는 이벤트 중재자가 핵심입니다.

시작 이벤트가 전체 이벤트 프로세스를 개시하는 이벤트인 점은 브로커 토폴로지와 동일하지만, 중재자 토폴로지에서는 시작 이벤트 큐를 거쳐 이벤트 중재자로 전달되는 차이점이 있습니다.

이벤트 프로세서가 다른 프로세서에게 자신이 한 일을 알리지 않는다는 것도 브로커 토폴로지와 다른 점입니다.

![image](https://github.com/user-attachments/assets/dbba795c-1403-41f0-8e49-4559f7210099)

알맞은 이벤트 중재자 구현체를 선택하려면 먼저 중재자를 통해 어떤 종류의 이벤트를 처리할 것인지 생각해봐야 합니다.

이벤트 복잡도를 한 가지 기준으로 평가하는 경우는 거의 없으므로 알기 쉽게 단순함, 어려움, 복잡함 정도로 분류한 뒤 모든 이벤트가 항상 단순한 중재자를 거치도록 하는 것이 좋습니다. 그러면 이 중재자는 이벤트 등급에 따라 이벤트를 직접 처리하거나 더 복잡한 다른 이벤트 중재자에게 위임합니다.

![image](https://github.com/user-attachments/assets/f6f62ce5-ab46-49cb-9c18-7a381ebe86a8)

두 토폴로지는 처리 이벤트의 의미와 사용 방법이 본질적으로 다릅니다. 브로커 토폴로지에서는 시스템에서 발생한 이벤트로서 처리 이벤트가 발행되고 이벤트 프로세서는 각자 맡은 일을 하면서 나머지 이벤트 프로세서는 그 액션에 반응하는 식으로 돌아갑니다.

하지만 중재자 토폴로지에서 처리 이벤트는 사건이미 일어난 일）이 아니라 커맨드（일어나야 할 일） 입니다. 따라서 중재자 토폴로지에서는 처리 이벤트가 반드시 처리되어야 할 이벤트인（커맨드） 반면, 브로커 토폴로지에서는 그냥무시해도 됩니다（반응）

이처럼 중재자 토폴로지는 브로커 토폴로지에서 불가능한 문제를 해결할 수 있지만 그만큼 부정적인 요소도 있습니다. 

- 복잡한 이벤트 흐름 내에서 발생하는 동적인 처리를 선언적으로 모델링하기가 매우 어렵습니다.
- 이벤트 프로세서는 브로커 토폴로지와 동일한 방식으로 쉽게 확장할 수 있지만, 그러자면 중재자도 함께 확장해야 하므로 전체이벤트 처리 흐름에 병목 지점이 생기기 쉽습니다.
- 중재자 토폴로지는 이벤트 처리를 중재자가 제어하므로 이벤트 프로세서가 상대적으로 더 많이 커플링되어 성능은 브로커 토폴로지보다좋지 않습니다

![image](https://github.com/user-attachments/assets/a54951dd-8391-4002-8c35-dd06a1b2ea79)

## **14.4** 비동기 통신

요청/응답 뿐만 아니라 파이어 앤드 포겟( 보내놓고 까먹어버리기 ~ )처리 모두 비동기 통신만 사용한다는 점에서 다른 아키텍처 스타일과 차별화됩니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cb2d10b1-40c0-4b97-99a8-9e8ba46135f0/b3ebafe1-925a-4c4c-8663-57e88332e490/image.png)

이것은 응답성과 성능의 차이점을 잘 보여주는 예입니다.

비동기 통신에서는 에러 처리가 가장 큰 문제입니다. 응답성은 엄청나게 개선되지만 에러를 제대로 처리하기가 쉽지 않기 때문에 이벤트 기반 시스템의 복잡도가 가중됩니다.

## **14.5** 에러 처리

리액티브 아키텍처의 워크플로 이벤트 패턴은 비동기 워크플로에서 에러 처리 문제를 해결하는 한 가지 방법입니다. 탄력성과 응답성이라는 두 마리 토끼를 겨냥한 리액티브 아키텍처 패턴의 일종이죠. 

워크플로 이벤트 패턴은 워크플로 대리자를 통해 위임, 봉쇄, 수리 작업을 합니다. 이벤트 프로듀서는 메시지 채널을 통해 데이터를 이벤트 컨슈머에게 비동기 전송하고, 이벤트 컨슈머가 데이터를 처리하는 도중 에러가 발생하면 즉시 해당 에러를 워크플로 프로세서에게 위임한 뒤 이벤트 큐에 있는 다음 메시지로 넘어갑니다. 이렇게 에러가 발생해도 바로 다음 메시지를 바로 처리하므로 전체 응답성은 영향을 받지 않습니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cb2d10b1-40c0-4b97-99a8-9e8ba46135f0/ceaa7736-9742-4b2d-92e6-6ea46cac898f/image.png)

워크플로 프로세서는 （사람의 개입 없이） 프로그래밍 방식으로 원데이터를 변경해서 긴급 조치한 후 원래 큐로 돌려보냅니다. 이벤트 컨슈머는 이 메시지를 새로운 메시지로 간주하여 이번에는 성공을 기대하며 재처리를 시도합니다.

워크플로 이벤트 패턴에서 한 가지 주의할 점은, 에러가 발생한 메시지를 조치 후 다시 제출하면 처리 순서가 바뀌는 것입니다.

계좌 번호가 동일한 거래는 나중에 처리할 수 있게 **（FIFO** 순서로） 임시 큐에 저장하면 되겠죠.

## **14.6** 데이터 소실 방지

불행하게도 이벤트 기반 아키텍처는 데이터가 소실될 만한 곳이 참 많습니다.

방지될 3 곳에 대해서 막는 방법을 알아봅시다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cb2d10b1-40c0-4b97-99a8-9e8ba46135f0/6ccb4c1d-24fe-46f7-93c6-8394587ea4af/image.png)

- **동기 전송 (Synchronous Transmission)**
    
    데이터를 전송할 때 송신 측과 수신 측이 동기화되어야 전송이 이루어지며, 수신 측에서 데이터를 받았다는 신호가 오면 다음 데이터를 보냅니다. 이를 통해 데이터 전송 중 손실이 발생할 가능성을 줄입니다.
    
- **퍼시스턴트 메시지 큐 (Persistent Message Queue)**
    
    메시지 큐에 들어온 데이터를 안정적으로 저장하고, 소비자(데이터를 받는 시스템)가 꺼내 갈 때까지 보관합니다. 중간에 시스템 장애가 생겨도 데이터가 안전하게 보관되므로 손실 위험이 낮아집니다.
    
- **클라이언트 확인응답 모드 (Client Acknowledgment Mode)**
    
    데이터가 수신자에게 도달했는지 확인 응답(ACK)을 받아야만 전송을 완료로 처리합니다. 수신자가 데이터를 안전하게 수신한 후 응답을 보낼 때까지 데이터를 재전송하는 방식으로 소실을 방지합니다.
    
- **최종 참여자 지원 (Last Participant Support)**
    
    마지막으로 데이터 처리에 참여한 노드(서버나 클라이언트)가 데이터의 일관성과 안전성을 책임지는 방식입니다. 특히 분산 시스템에서 데이터를 다루는 경우 마지막 참여자가 모든 데이터를 수신하고 완료 상태를 확인할 때까지 데이터를 안전하게 관리합니다.
    

## **14.7** 브로드캐스팅

이벤트 기반 아키텍처는 메시지를 누가 받든（컨슈머가 있다면）, 그 메시지로 무슨 일을 하든 상관없이 이벤트를 브로드캐스트(전파)할 수 있습니다. 메시지 프로듀서는 자신이 보낸 메시지를 어느 이벤트 프로세서가 수신할지, 또 메시지를 받아무슨 일을 할지 모릅니다. 그러므로 어쩌면 브로드캐스팅은 여러 이벤트 프로세서를 가장 높은 수준으로 디커플링하는 수단이 며, 최종 일관성 등 다양한 쓰임새를 지닌 필수 기능입니다.

## 14.8 요청-응답

지금까지는 이벤트 컨슈머의 즉시 응답이 필요하지 않은 비동기 요청만을 이야기했습니다. 그런데 동기적인게 필요하다면 ?

처음 정보를 요청하면 요청 큐에 비동기 전송된 후 메시지 프로듀서에게 제어권이 반환되며 메시지 프로듀서는응답 큐에 응답이 도착하길 기다리며 차단 대기상태가 됩니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cb2d10b1-40c0-4b97-99a8-9e8ba46135f0/16aaff99-7474-4fde-b595-4e79018c31e3/image.png)

요청一응답 메시징을 구현하는 주요한 기술은 두 가지입니다.

- ID 를 만들어서 같은 ID 로 확인하는 방법

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cb2d10b1-40c0-4b97-99a8-9e8ba46135f0/9364f648-4c92-46a6-b4ae-73f3f0e1cd69/image.png)

- 미니 큐 만들어서 하는 방법

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cb2d10b1-40c0-4b97-99a8-9e8ba46135f0/4e25b4de-7999-473a-a9ab-5fb3f9784faa/image.png)

기술적으로는 임시 큐가 훨씬 단순하지만 메시지 브로커는 매번 요청을 할 때마다 임시 큐를 생성/폐기하는 일을 반복해야 합니다. 따라서 대용량 메시지 처리 시 메시지 브로커의 속도가 크게 떨어지고 전체 성능과 응답성 역시 영향을 받을 수 있습니다. 그래서 우리는 대체로 상관 ID를 사용하는 방법을 권장합니다

## 14.9 요청 기반이냐, 이벤트 기반이냐.

표로 한 번에 정리됨.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/cb2d10b1-40c0-4b97-99a8-9e8ba46135f0/ff42d8df-fddb-4b91-91ac-4a605742d897/image.png)

## **14.10** 하이브리드 이벤트 기반 아키텍처

이벤트 기반 아키텍처와 다른 아키텍처 스타일을 함께 사용하는 하이브리드 아키텍처 기반의 애플리케이션도 있습니다. ( 이벤트 기반 마이크로커널 아키텍처, 이벤트 기반 파이프라인 아키텍처)

벤트 기반 아키텍처를 추가하면 병목 지점을 제거하고 이벤트 요청을 백업하는 배압 지점을 확보하는 데 유용하며,
다른 아키텍처 스타일에서는 찾아볼 수 없는 유저 응답성이 보장됩니다.

## **14.11** 아키텍처특성 등급

이벤트 기반 아키텍처는 특정 도메인이 여러 이벤트 프로세서에 분산되어 있고 중재자, 큐, 토픽을 통해 서로 묶여 있는, 기술 분할된 아키텍처입니다. 한 도메인에 변경이 발생하면 많은 이벤트 프로세서, 중재자, 다른 메시징 아티팩트에도 영향을 미치므로 이벤트 기반 아키텍처는 도메인 분할 아키텍처는 아닙니다.

모든 통신은 비동기로 이루어지지만 여러 이벤트 프로세서가 단일 데이터베이스 인스턴스를 공유하는 경우 전부 동일한 아키텍처 퀀텀 내에 포함됩니다.

이벤트 프로세서는 프로그래밍 방식의 로드 밸런싱이 가능하며 확장성이 매우 뛰어납니다. 요청 부하가 증가하면 프로그래밍 방식으로 이벤트 프로세서를 추가해서 증가된 요청을 처리할 수 있습니다.

또 이벤트 워크플로의 최종 일관성 및 최종 처리를 제공하는 고도로 분리된 비동기 이벤트 프로세서를 활용하면 내고장성을 실현할 수 있습니다. 

이 아키텍처는 특유의 비결정적 동적인 이벤트 흐름 때문에 단순성과 시험성은 상대적으로 낮은 편입니다. 요청 기반 모델의 확정적인 흐름은 경로와 결과가 잘 알려져 있으므로 비교적 테스트하기 쉽지만 이벤트 기반 모델은 그렇지 않습니다.
