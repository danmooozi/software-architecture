# 15.공간 기반 아키텍처스타일

웹 기반 비즈니스 애플리케이션은 대부분 일반적인 요청 흐름을 따라갑니다.

이런 패턴은 유저가 많지 않으면 별 문제없지만 유저 수가 늘어나면 점점 병목 현상이 나타나기 시작합니다.

유저 수증가에 따른 병목 현상의 가장 일반적인 해결 방법은 웹 서버 확장입니다.

동시 유저 부하가 많은 대용량 애플리케이션은 데이터베이스의 동시 처리 가능한 트랜잭션 수가 최종 제약조건이 되는 경우가 많습니다. 다양한 캐시 기술과 데이터베이스 확장 제품으로 문제를 해결할 수는 있지만, 부하가 엄청나게 밀려 들어오는 상황에서 여느 애플리케이션을 확장하는 작업은 결코 만만치 않습니다.

## **15.1** 토폴로지

공간 기반 아키텍처라는 명칭은 튜플 공간에서 유래됐습니다. 튜플 공간은 공유 메모리를 통해 통신하는 다중 병렬 프로세서를 사용하는 기술입니다. *튜플* 공간은 공유 메모리를 통해 통신하는 다중 병렬 프로세서를 사용하는 기술입니다. 시스템에서 동기 제약조건인 중앙 데이터베이스를 없애는 대신 복제된 인메모리 데이터 그리드를 활용하면 확장성, 탄력성, *성능을* 높일 수 있습니다. 애플리케이션 데이터는 메모리에 둔 상태로 모든활성 처리 장치들이 데이터를 복제합니다. 처리 장치는 데이터를 업데이트할 때 퍼시스턴스 큐에 메시지를 보내는 식으로 데이터베이스에 데이터를 비동기 전송합니다.

중앙 데이터베이스가 애플리케이션의 표준 트랜잭션 처리에 관여하지 않으므로 데이터베이스 병목 현상이 사라지고 애플리케이션은 거의 무한에 가까운 확장성이 보장됩니다.

![image](https://github.com/user-attachments/assets/2feac104-6c40-478c-9fad-280d7c78758c)

### **15.1.1** 처리 장치

처리 장치는 애플리케이션 로직 （또는 로직의 일부분）을 갖고 있습니다. 보통 웹 기반 컴포넌트와 백엔드 비즈니스 로직이 포함되나 애플리케이션 종류마다 내용물은 달라집니다.

작은 웹기반 애플리케이션은 단일 처리 장치에 배포할 수 있지만, 대규모 애플리케이션은 기능별로 여러 처리 장치에 나누어 배포해야 합니다.

![image](https://github.com/user-attachments/assets/c90fb747-b5ef-43fd-871d-b699d46efa8e)

### **15.1.2** 가상 미들웨어

가상 미들웨어는 아키텍처 내부에서 데이터 동기화 및 요청 처리의 다양한 부분을 제어하는 인프라를 담당합니다.

- 메시징 그리드

입력 요청과 세션 상태를 관리합니다.

가상 미들웨어에 요청이 유입되면 메시징 그리드는 어느 활성 처리 장치가 요청을 받아 처리할지 결정하여 해당 처리 장치로 요청을 전달합니다.

메시징 그리드의 복잡도는 단순 라운드 로빈 알고리즘부터 처리 장치가 요청 처리 상태를 추적하는 복잡한 알고리즘까지 다양합니다

- 데이터 그리드

데이터 그리드는 이 아키텍처 스타일에서 가장 중요하고 필수적인 컴포넌트입니다.

요즘은 데이터 그리드가 거의 대부분 복제 캐시로서 처리 장치에만 구현되어 있지만, 외부 컨트롤러가 필요한 복제 캐시 구현체나 분산 캐시를 사용할 경우, 데이터 그리드는 가상 미들웨어 내부의 데이터 그리드 컴포넌트와 처리 장치 모두에 위치합니다.

- 배포 관리자

배포 관리자는 부하 조건에 따라 처 리 장치 인스턴스를 동적으로 시작/종료하는 컴포넌트입니다. 

### **15.1.3** 데이터 펌프

데이터 펌프는 데이터를 다른 프로세서에 보내 데이터베이스를 업데이트하는 장치입니다. 공간 기반 아키텍처에서는 처리 장치가 데이터를 데이터베이스에 직접 읽고 쓰지 않으므로 데이터 펌프는 반드시 필요합니다. 

또 데이터 펌프는 항상 비동기로 동작하면서 메모리 캐시와 데이터베이스의 최종 일관성을 실현합니다.

### **15.1.4** 데이터 라이터

데이터 라이터는 데이터 펌프에서 메시지를 받아 그에 맞게 데이터베이스를 업데이트하는 컴포넌트입니다**.** 데이터 라이터는 서비스나 애플리케이션 데이터 허브로 구현할 수 있습니다. 데이터 라이터의 세분도는 데이터 펌프와 처리 장치의 범위마다 다릅니다.

### **15.1.5** 데이터 리더

데이터 라이터가 데이터베이스 업데이트를 담당한다면 데이터 리더는 데이터베이스에서 데이터를 읽어 리버스 데이터 펌프를 통해 처리 장치로 실어 나르는 컴포넌트입니다. 공간 기반 아키텍처에서 데이터 리더는 세 가지 경우에만 작동됩니다.

첫째,동일한 이름의 캐시를 가진 모든 처리 장치 인스턴스가 실패하는 경우

둘째,동일한 이름의 캐시 안에서 모든 처리 장치를 재배포하는 경우

셋째,복제 캐시에 들어있지 않은 아카이브 데이터를 조회하는 경우입니다.

## **15.2** 데이터 충돌

이름이 동일한 캐시가 포함된 서비스 인스턴스에 시시각각 업데이트가 일어나는 active/active 상태에서 복제 캐시를 사용하면 복제 레이턴시 때문에 데이터 충돌이 발생할 수 있습니다.

![image](https://github.com/user-attachments/assets/76b09d96-436c-42a9-92b7-809582fc1f66)

이 식에서 N은 동일한 이름의 캐시를 사용하는 서비스 인스턴스 수, UR은 밀리초 당 업데이트율, S는 캐시 크기,  RL 캐시 제품의 복제 대기 시간입니다

대부분의 시스템은 정상적인 경우에 이렇게 오래 꾸준히 업데이트를 하지 않습니다.

따라서 충돌률을 계산할 때에는 사용량이 가장 많은 시점의 최대 업데이트율에 따라 최소, 정상, 최대 충돌률을 산출하는 것이 바람직합니다.

## **15.3** 클라우드 대 온프레미스 구현

공간 기반 아키텍처는 배포 환경 측면에서 독자적인 선택지가 있습니다.

전체 토폴로지는 클라우드 기반의환경이나 온프레미스（‘온프렘’）에 배포할 수 있습니다. 하지만 이 두 환경 사이에 어중간하게 배포할 수도 있는데, 이것이 다른 아키텍처 스타일에서는 찾아볼 수 없는 이 아키텍처의 특징입니다.

아니 근데 vs 라고 써놓고, 하이브리드를 내놓는건 누구 머리 속에서 나온거야?

![image](https://github.com/user-attachments/assets/9fc79259-a47f-4045-94f4-d1b85ee93317)

## **15.4** 복제 캐시 대 분산 캐시

![image](https://github.com/user-attachments/assets/3972810f-67e3-4ce8-82d1-9367e837e8f8)

공간 기반 아키텍처에서 캐시 모델을 선정할 때에는 대부분의 경우 주어진 애플리케이션 콘텍스트에서 두 모델 모두 적용 가능하다는 점을 기억하세요. 즉, 복제 캐시든 분산 캐시든 어느한 모델로 모든 문제를 해결할 수는 없습니다. 애플리케이션 전체적으로 일관된 단일 캐시 모델을 통해 타협점을 모색하되 각 모델의 장점을 최대한 활용해야 합니다.

## **15.5** 니어 캐시

니어 캐시(준캐시)는 분산 캐시와 인메모리 데이터 그리드를 접합한 일종의 하이브리드 캐시 모델입니다.이 모델에서 분산 캐시는 풀 백킹 캐시 각 처리 장치에 포함된 인메모리 데이터 그리드는 프런트 캐시라고 합니다.

프런트 캐시는 항상 풀 백킹 캐시보다 작은 서브세트를 담고 있고 방출 정책을 통해 옛 항목을 삭제한 다음 최근 항목을 추가합니다. 프런트 캐시는 가장 최근에 사용한 항목이 포함된 MRU 캐시 또는 가장 자주 사용한 항목이 포함되는 MFU 캐시로 사용합니다. 새 항목을 추가할 공간이 필요할 때마다 무작위로 항목을 삭제하는 랜덤 교체도 프런트 캐시에 적용 가능한 방출 정책입니다. 랜덤 교체는 가장 최근에 사용된 데이터와 가장 자주 사용된 데이터를 확실하게 분석할 수 없을 경우에 유용한 정책입니다.

프런트 캐시는 항상 풀 백킹 캐시와 동기화되지만 각 처리 장치에 포함된 프런트 캐시는 동일한 데이터를 공유하는 다른 처리 장치와 동기화되지 않습니다. 즉, 동일한 데이터 콘텍스트를 공유하는 여러 처리 장치가 동일하지 않은 데이터를 각자의 프런트 캐시에 소유하게 될 수도 있습니다. 이처럼 처리 장치마다 상이한 데이터를 프런트 캐시에 갖게 되고 처리 장치 간 성능과 응답성의 일관성이 결여됩니다. 따라서 우리는 공간 기반 아키텍처에서 니어 캐시 모델을 권장하지 않습니다.

## **15.7** 아키텍처 특성 등급

![image](https://github.com/user-attachments/assets/a3d7f93c-7156-49ff-ac51-2ac5f86ccc0d)

공간 기반 아키텍처는 탄력성, 확장성, 성능의 끝판왕입니다. 이 아키텍처는 인메모리 데이터 캐시를 활용하고 제약조건에 해당되는 데이터베이스를 없앴기 때문에 이 세 가지 특성을 높은 수준으로 달성할 수 있습니다.

전체적인 단순성과 시험성 측면에서는 트레이드오프가 있습니다. 공간 기반 아키텍처는 주요 데이터 저장소에서 캐시를 사용하고 최종 일관성이라는 개념을 적용하기 때문에 구조가 매우 복잡한 아키텍처입니다.

고도의 확장성과 탄력성을 시뮬레이션하는 복잡도 때문에 시험성은 별점 1개를 개를 부여했습니다.

이 아키텍처 스타일에서 비용 역시 고려해야 할 팩터입니다. 클라우드 및 온 프레미스 시스템에서 높은 확장성과 탄력성을 실현하려면 상용 캐시 제품을 사용해야 하는데, 라이선스 비용을 지불해야 하고 리소스 사용률이 높기 때문에 상대적으로 돈이 많이 듭니다
