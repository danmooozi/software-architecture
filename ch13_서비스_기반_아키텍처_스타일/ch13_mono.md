# 13.서비스 기반 아키텍처 스타일

마이크로서비스 아키텍처 스타일의 일종

분산 아키텍처지만 비교적 덜 복잡하고 비용이 많이 들지 않음

## **13.1** 토폴로지

서비스 기반 아키텍처의 기본 토폴로지는 각각 따로 배포된 유저 인터페이스와 원격 서비스

![image](https://github.com/user-attachments/assets/aa5c7784-c742-422f-bb63-88370b4cb354)

이 아키텍처 스타일에서 서비스는 큼지막한 단위로 분리해 별도로 배포하는 ‘애플리케이션의 일부’입니다（보통 도메인 서비스라고 함）

서비스 기반 아키텍처의 도메인 서비스는 각각 단일 인스턴스로 배포하지만 요구사항에 따라 인스턴스를 여럿 둘 수도 있습니다.

서비스 기반 아키텍처는 중앙 공유 데이터베이스를 사용한다는 특징이 중요합니다.

따라서 서비스는 기존 모놀리식 레이어드 아키텍처와 동일한 방식으로 SQL 쿼리와 조인 기능을 사용하면 됩니다

## **13.2** 토폴로지 변형

서비스 기반 아키텍처 스타일은 특유의 유연성 때문에 정말 다양한 변형이 존재합니다.

![image](https://github.com/user-attachments/assets/50bc226d-3739-41af-9fd2-5b05bf147c08)

단일 모놀리식 유저 인터페이스는 다시 여러 유저 인터페이스 도메인으로 나눌 수 있고, 한술 더 떠 각 도메인 서비스에 맞게 나눌 수도 있습니다.

단일 모놀리식 데이터베이스 역시 개별 데이터베이스로 분리할 수 있고 각 도메인 서비스 전용 데이터베이스들로 쪼갤 수도 있습니다.

## **13.3** 서비스 설계 및 세분도

서비스 기반 아키텍처의 도메인 서비스는 보통 단위가 크기 때문에 도메인 서비스를 API 퍼사드 레이어, 비즈니스 레이어, 퍼시스턴스 레이어로 구성된 레이어드 아키텍처 스타일로 설계하는 것이 일반적입니다.

모듈러 모놀리스 아키텍처 스타일처럼 서브도메인을 이용해서 각 도메인 서비스를 분할하는 방법도 많이 쓰입니다.

![image](https://github.com/user-attachments/assets/4e6a2a50-4993-4ea9-86d3-b851513a4c56)

서비스를 어떻게 설계하든 도메인 서비스는 유저 인터페이스에서 비즈니스 기능을 호출하기 위해 접속할 일종의 API 액세스 퍼사드를 필요로 합니다. API 액세스 퍼사드는 유저 인터페이스를 통해 유입된 비즈니스 요청을 오케스트레이트하는 역할을 합니다.

도메인 서비스는 세분도가 *큰* 까닭에 단일 도메인 서비스에서 데이터 무결성을 보장하기 위해 커밋/롤백이 수반되는 여느 ACID 데이터베이스 트랜잭션을 사용하지만 마이크로서비스처럼 분산도가 높은 아키텍처는 서비스를 더 잘게 나누어 BASE 트랜잭션 이라고 알려진 분산 트랜잭션 기법을 사용합니다.

이 기법은 그 기반이 최종 일관성이므로 서비스 기반 아키텍처의 ACID 트랜잭션 레벨의 데이터 무결성은 지원하지 않습니다.

도메인 서비스는 단위가 커서 데이터 무결성과 일관성 측면에서는 유리하지만 그에 못지않은 트레이드오프도 있습니다.

## **13.4** 데이터베이스 분할

서비스 기반 아키텍처의 서비스는 （반드시 그래야 하는 건 아니지만） 주어진 애플리케이션 콘텍스트에서 서비스 수**（**4〜12개）가 적은 편이라서 보통 단일 모놀리식 데이터베이스를 공유합니다. 그러나 이러한 데이터베이스 커플링은 테이블 스키마 변경 시 문제가 될 수 있습니다. 테이블 스키마를 올바르게 변경하지 않을 경우 모든 서비스에 악영향을 미치기 때문에 데이터베이스 변경은 여러모로 노력과 조정이 필요한 값비싼 작업입니다.

## **13.6** 아키텍처 특성 등급

![image](https://github.com/user-attachments/assets/4582d37a-21e3-437e-b498-6342a4644c8f)

서비스 기반 아키텍처는 도메인 분할된 아키텍처입니다. 기술 관심사보다 도메인을 위주로 구성된 아키텍처입니다.  앞서 예시한 전자 제품 재활용 애플리케이션에서 각 서비스는 별도 배포되는 소프트웨어 단위로서 그 범위가

특정 도메인으로 한정됩니다.

이 아키텍처는 분산 아키텍처이므로 퀀텀은 하나 또는 그 이상일 것입니다. 개별 배포된 서비스가 4〜12개라도 이들 모두가 동일한 데이터베이스나 유저 인터페이스를 공유할 경우 전체 시스템의 퀀텀은 1입니다.

서비스를 잘게 나누는 것보다 중복되는 기능이 많아 머신 리소스 및 비용 측면에서 별로 효율적이지는 않습니다. 그리고 처리량이나 페일오버를 개선해야 하는 요건이 따로 없다면 서비스 인스턴스는 딱 하나만 있습니다.

서비스 기반 아키텍처는 도메인 서비스를 굵직굵직하게 나누기 때문에 다른 분산 아키텍처에 비해 신뢰성이 우수합니다. 대규모 서비스는 서비스 간 네트워크 트래픽이 적고 대역폭을 덜 사용하며, 분산 트랜잭션이 많지 않기 때문에 전반적으로 네트워크 측면에서 신뢰성이 좋습니다.

## **13.7** 언제 이 아키텍처 스타일을 사용하는가

서비스 기반 아키텍처는 별점 서너 개를 받은 아키텍처 특성과 결부된 아키텍처 스타일의 유연성（13.2절） 덕분에 어쩌면 가장 실용적인 아키텍처입니다.

서비스 기반 아키텍처는 도메인 주도 설계와 궁합이 잘 맞습니다. 서비스를 큰 단위로 나누고 그 범위를 도메인으로 한정하기 때문에 각 도메인은 개별 배포된 도메인 서비스에 딱 맞아떨어지는 거죠.

분산 아키텍처에서는 데이터베이스 트랜잭션을 관리/조율하는 일이 늘 골칫거리입니다.

끝으로, 서비스 기반 아키텍처는 복잡하게 뒤얽히거나 세분도의 함정에 빠져 허우적거리지 않고도 아키텍처 모듈성을 괜찮은 수준으로 달성할 수 있습니다.
