# 17. 마이크로서비스 아키텍처 스타일

## **17.1** 역사

마이크로서비스는 소프트웨어 프로젝트의 논리적 설계 프로세스를 강조한 도메인 주도 설계 사상의 영향을 많이 받았습니다. 특히, 디커플링 스타일을 나타낸 경계 콘텍스트 개념은 마이크로서비스에 결정적인 영향을 미쳤습니다. 전통적인 모놀리식 아키텍처에서 개발자는 이런 수많은 개념을 공유하고 재사용 가능한 클래스를 만들어 데이터베이스에 접속했습니다.

재사용은 유익하지만 커플링이 문제입니다. 재사용을 선호하는 시스템을 설계하다 보면 결국 상속이나 조합을 이용하여 재사용하기 위해 커플링이 맺어지게 됩니다.

그러나 고도의 디커플링이 아키텍트의 목표라면 재사용보다 중복을 우선할 것입니다. 마이크로서비스의 주요 목표는 경계 콘텍스트의 논리적 개념을 물리적으로 모델링하는 고도의 디커플링입니다.

## 1**7.2** 토폴로지

![image](https://github.com/user-attachments/assets/25fd344c-7b1d-4f55-9e80-89d81b7144a3)

마이크로서비스는 단일 목적만 가지기 때문에 오케스트레이션 기반의 서비스 지향 아키텍처와 같은 다른 분산 아키텍처보다 서비스 규모가 훨씬 작습니다. 실제로 각 서비스에는 데이터베이스 및 기타 종속적인 컴포넌트 등 서비스가 독립적으로 작동되는 데 필요한 모든 것들이 준비되어 있습니다.

## **17.3** 분산

마이크로서비스는 분산 아키텍처를 형성합니다. 서비스는 자체 프로세스로 실행되며, 원래 물리적인 컴퓨터를 의미했지만 이제는 가상 머신과 컨테이너로 빠르게 진화했습니다. 서비스를 이 정도로 디커플링하면 애플리케이션을 호스트하는 육중한 멀티테넌트 인프라 아키텍처에서 자주 발생하는 문제들을 간단히 해결할 수 있습니다.

다수의 애플리케이션을 관리할 때에도 네트워크 대역폭, 메모리, 디스크 공간 등 여러 가지 혜택을 운영 측면에서 재사용할 수 있습니다. 그러나 지원해야 할 애플리케이션이 계속 늘어나면 결국 일부 리소스는 공유 인프라의 제약을 받을 수밖에 없습니다. 또 공유 애플리케이션 간의 잘못된 분리도 문제가 되는 경우가 있습니다.

이처럼 뭔가 공유함으로써 불거지는 문제들은 각 서비스를 자체 프로세스로 분리하면 모두 자연스럽게 해소됩니다. 

마이크로서비스의 분산 속성 탓에 성능은 다소 부정적입니다.

마이크로서비스는 분산 아키텍처의 일종이므로 숙련된 아키텍트라면 개발자가 서비스 경계를 넘나드는 트랜잭션을 사용하지 않도록 권고해야 합니다.

## 1**7.4** 경계 콘텍스트

마이크로서비스의 근본 철학은 경계 콘텍스트 개념 입니다. 서비스마다 도메인이나 워크플로를 모델링하는 개념이지요. 클래스, 기타 부속 컴포넌트, 데이터베이스 스키마 등 애플리케이션 작동에 필요한 모든 것들이 각 서비스에 들어갑니다.

마이크로서비스는 커플링을 가급적 삼가므로 이 아키텍처 스타일을 구축하는 아키텍트는 커플링보다는 차라리 중복이 낫다고 생각합니다.

마이크로서비스는 도메인 분할 아키텍처의 개념을 극도로 우려낸 결과물입니다.

### **17.4.1** 세분도

아키텍트는 마이크로서비스의 알맞은 세분도를 찾기 위해 고심하다가 종종 서비스를 너무 잘게 나누는 실수를 저지르곤 합니다. 그래서 뭔가 유용한 작업을 하려면 서비스 간 통신 링크를 다시 구축해야 하는 지경에 이르죠.

서비스 경계는 도메인이나 워크플로를 캡처하는 것이 목표입니다. 아키텍트가 적절한 경계를 찾는 데 도움이 될 만한 몇 가지 가이드라인을 제시하겠습니다.

목적

가장 확실한 경계는 바로 이 아키텍처 스타일의 본래 의도인 도메인입니다. 각 마이크로서비스가 기능적으로 매우 응집되어 있고 전체 애플리케이션을 대표하여 하나의 핵심 기능을 제공하는 것이 가장 이상적인 모습입니다.

트랜잭션

여러 엔티티가 함께 개입하여 작동되는 트랜잭션은 아키텍트에게 좋은 서비스 경계 후보입니다. 분산 아키텍처에서 트랜잭션은 문제가 될 소지가 있으므로 그런 문제를 방지할 수 있도록 설계하는 것이 바람직합니다.

코레오그래피

도메인 격리는 아주 잘 되어 있지만 서로 광범위한 통신을 해야 제대로 작동되는 서비스 세트를 구축할 경우, 아키텍트는 통신 오버헤드를 줄이기 위해 더 큰 서비스로 다시 뭉치는 것을 고려해야 할 수도 있습니다. 좋은 서비스 설계안을 도출하는 유일한 방법은 이터레이션입니다. 여러 가지 옵션을 반복해서 적용해보면 좋은 방향으로 설계를 다듬어갈 수 있습니다.

### **17.4.2** 데이터 격리

마이크로서비스는 경계 콘텍스트 개념에 따라 데이터를 격리해야 합니다. 대부분의 다른 아키텍처는 데이터를 단일 데이터베이스에 저장하지만, 마이크로서비스 아키텍처는 통합 지점으로 사용되는 공유 스키마, 데이터베이스 등 모든 종류의 커플링을 없애려고 합니다.

데이터 격리는 아키텍트가 서비스 세분도를 살필 때 반드시 고려해야 할 팩터입니다. 아키텍트는 시스템 내부 값들을 관계형 데이터베이스로 통합하여 단일 진실 공급원을 만드는 일에 익숙합니다. 그러나 마이크로서비스 아키텍처에서는 이렇게 하면 안 되므로 어떻게 하면 아키텍처 전체에 데이터를 분산시킬 수 있을지 결정해야 합니다.

이 정도 수준의 데이터 격리만으로도 골치가 아프지만 긍정적인 부분도 있습니다. 이제 여러 팀이 단일 데이터베이스의 속박에서 벗어나게 되어 각 서비스마다 단가, 스토리지, 그밖의 요소들의 여러 요소들을 저울질하여 가장 적합한 도구를 선택할 수 있습니다.

## **17.5 API** 레이어

마이크로서비스 다이어그램을 보면 대부분 필수는 아니지만 여러 시스템 컨슈머 사이에 API 레이어 （유저 인터페이스 또는 다른 시스템의 호출）가 있습니다.

API 레이어는 다양한용도로 활용할 수 있지만 이 아키텍처의 기본 철학에 충실하려면 API 레이어를 중재자나 오케스트레이션 도구로 사용하지 말아야 합니다. 모든 비즈니스 로직은 경계 콘텍스트 내부에서 일어나야 하며, 오케스트레이션 등의 다른 로직을 중재자에 넣는 것은 규칙 위반입니다.

## **17.6** 운영 재사용

앞서 마이크로서비스가 커플링보다 복제를 선호한다고 했습니다.  그러면 모니터링,로깅, 회로 차단기 등의 운영 관심사와같이 실제로 커플링이 더 유리한 아키텍처 부분은 어떻게 처리해야할까요? 전통적인 서비스 지향 아키텍처의 철학에 따르면 도메인이든 운영이든 가급적 많은 기능을 재사용하는 것이 좋습니다.

여러 마이크로서비스를 구축한 이후에 잘 살펴보면 각 마이크로서비스에 공통적인 요소가 있고 그 유사성을 활용하면 더 유리한 부분이 있음을 알게 됩니다.

이 문제를 해결하는 방법이 바로 사이드카 패턴입니다.

![image](https://github.com/user-attachments/assets/d577e103-4d21-4539-a024-34336b64aa17)

사이드카 컴포넌트는 팀이 서로 커플링되면 더 유리한 모든 운영 관심사를 도맡아 처리합니다. 따라서 가령 모니터링 도구를 업그레이드할때가 되면 공유 인프라팀이 사이드카를 업데이트하는 방식으로 각 마이크로서비스는 신기능을 받아사용할 수 있습니다. 서비스 메시에서 서비스 플레인은 사이드카를 서로 연결한다.

아키텍트는 마이크로서비스 아키텍처에 탄력성을 부여하는 수단으로 서비스 디스커버리를 사용합니다. 그런데 어느 하나의 서비스를 직접 호출하는 게 아니라 모든 요청이 서비스 디스커버리 도구를 거치도록 하면 요청 수와 빈도를 모니터링할 수 있고 필요시 서비스 인스턴스를 늘려 확장성/탄력성을 *줄* 수 있습니다.

## 1**7.7** 프런트엔드

마이크로서비스는 디커플링을 선호합니다. 유저 인터페이스와 백엔드 역시 분리되는 모습이 가장 좋지요. 마이크로서비스 초기 비전에는 유저 인터페이스가 DDD 원칙에 충실한 경계 콘텍스트의 일부로 포함되어 있었지만, 웹 애플리케이션 및 여타 외부 제약조건에서 필요로 하는 분할의 실용성 때문에 이 목표는 달성하기 어렵습니다. 그래서 마이크로서비스 아키텍처의 유저 인터페이스는 보통 두 가지 스타일로 나타납니다.

- 모놀리식 프런트엔드
- 마이크로 프런트엔드

## 1**7.8** 통신

마이크로서비스를 구축하는 아키텍트와 개발자는 데이터 격리와 통신 모두에 영향을 미치는 적절한 세분도를 찾고자 씨름합니다. 올바른 통신 스타일을 발견하는 것 또한 팀이 서비스를 디커플링하면서 유용한 방향으로 조정하는 데 도움이 됩니다.

프로토콜 인구

마이크로서비스는 운영 커플링을 방지하고자 중앙 통합 허브를 갖고 있지 않기 때문에 각 서비스는 다른 서비스를 호출하는 방법을 알고 있어야 합니다. 즉, 서비스는 다른 서비스를 호출할때 어떤 프로토콜을 사용할지 알아야（또는 발견해야） 합니다.

이종

마이크로서비스는 분산 아키텍처라서 각 서비스마다 구현 기술 스택이 상이할 수 있습니다.

이종이란, 서비스마다 사용하는 플랫폼이 저마다 다른 폴리글랏(폴리글랏(polyglot)은 **여러 언어를 구사하는 것을 말한다)** 환경을 완벽하게 지원한다

상호 운용성

여러 서비스가 서로 호출한다는 뜻입니다. 마이크로서비스에서 트랜잭셔널 메서드 호출은 권장하지 않지만, 어쨌거나 서비스는 네트워크를 통해 다른 서비스를 호출하여 정보를 주고받으면서 협력해야 합니다.

## **17.9** 아키텍처 특성 등급

![image](https://github.com/user-attachments/assets/d89b5774-1135-4450-86f1-be0ade9c2901)
