# CHAPTER17 마이크로서비스 아키텍처 스타일

## 17.1 역사

마이크로서비스는 소프트웨어 프로젝트의 논리적 설계 프로세스를 강조한 도메인 주도 설계 사상의 영향을 많이 받았습니다. 특히, 디커플링 스타일을 나타낸 경계 콘텍스트 개념은 마이크로서비스에 결정적인 영향을 미쳤습니다. 경계 콘텍스트 내부에서는 코드, 데이터 스키마 같은 내부 요소들이 함께 연결되어 작동되지만, 경계 콘텍스트 외부에 있는 것들은 전혀 커플링되지 않습니다.

## 17.2 토폴로지

## 17.3 분산

마이크로서비스는 분산 아키텍처를 형성합니다. 서비스는 자체 프로세스로 실행되며, 원래 물 리적인 컴퓨터를 의미했지만 이제는 가상 머신과 컨테이너로 빠르게 진화했습니다. 

마이크로서비스의 분산 속성 탓에 성능은 다소 부정적입니다. 아무래도 네트워크 호출은 메서드 호출보다 오래 걸리고 엔드포인트마다 보안 검증 절차를 거치면 그만큼 처리 시간이 소요되므로 시스템을 설계하는 아키텍트는 서비스 세분도에 대해 심사숙고해야 합니다.

## 17.4 경계 콘텍스트

마이크로서비스는 도메인 분할 아키텍처의 개념을 극도로 우려낸 결과물입니다. 각각의 마이크로서비스는 어느 한 도메인이나 그 서브도메인을 나타냅니다.

### 17.4.1 세분도

**목적**

가장 확실한 경계는 바로 이 아키텍처 스타일의 본래 의도인 도메인입니다. 각 마이크로서비스 가 기능적으로 매우 응집되어 있고 전체 애플리케이션을 대표하여 하나의 핵심 기능을 제공하 는 것이 가장 이상적인 모습입니다.

**트랜잭션**

여러 엔티티가 함께 개입하여 작동되는 트랜잭션은 아키텍트에게 좋은 서비스 경계 후보입니 다. 분산 아키텍처에서 트랜잭션은 문제가 될 소지가 있으므로 그런 문제를 방지할 수 있도록 설계하는 것이 바람직합니다.

**코레오그래피**

도메인 격리는 아주 잘 되어 있지만 서로 광범위한 통신을 해야 제대로 작동되는 서비스 세트 를 구축할 경우, 아키텍트는 통신 오버헤드를 줄이기 위해 더 큰 서비스로 다시 뭉치는 것을 고 려해야 할 수도 있습니 다.

### 17.4.2 데이터 격리

아키텍트는 시스템 내부 값들을 관계형 데이터베이스로 통합하여 단일 진실 공급원을 만드는 일에 익숙합니다. 그러나 마이크로서비스 아키텍처에서는 이렇게 하면 안 되므로 어떻게 하면 아키텍처 전체에 데이터를 분산시킬 수 있을지 결정해야 합니다.

## 17.5 API 레이어

마이크로서비스 다이어그램을 보면 대부분 필수는 아니지만 여러 시스템 컨슈머 사이에 API 레이어 (유저 인터페이스 또는 다른 시스템의 호출)가 있습니다. API 레이어는 프록시를 경유 하여 간접화하거나 네이밍 서비스(17.6절) 같은 운영 장치에 물려서 유용한 작업을 수행하기 좋은 위치에 있기 때문에 이 아키텍처에서 많이 쓰입니다.

## 17.6 운영 재사용

사이드카패턴으로 문제를 해결하고자 함.

공통 운영 관심사를 각 서비스마다 별도의 컴포넌트에 두고, 해당 팀이나 공유 인프라팀이 소유할 수 있도록 합니다.

## 17.7 프런트엔드

## 17.8 통신

**프로토콜 인자**

마이크로서비스는 운영 커플링을 방지하고자 중앙 통합 허브를 갖고 있지 않기 때문에 각 서비 스는 다른 서비스를 호출하는 방법(REST 레벨, 메시지 큐 등)을 알고 있어야 합니다. 즉, 서비스는 다른 서비스를 호출할 때 어떤 프로토콜을 사용할지 알아야(또는 발견해야) 합니다.

**이종**

마이크로서비스는 분산 아키텍처라서 각 서비스마다 구현 기술 스택이 상이할 수 있습니다. 이
종이란, 서비스마다 사용하는 플랫폼이 저마다 다른 폴리글랏환경을 완벽하게 지원한다 는 뜻입니다.

**상호 운용성**

### 17.8.1 코레오그래피와 오케스트레이션

비동기 통신은 이벤트와 메시지를 주로 사용하며 내부적으로 이벤트 기반 아키텍처를 활용합니다(14장 참고). 브로커 패턴과 중재자 패턴은 마이크로서비스에서 각각 코레오그래피 패턴과 오케스트레이션 패턴으로 나타납니다.

코레오그래피는 브로커 이벤트 기반의 아키텍처와 통신 스타일이 동일합니다. 각 서비스는 중앙 중재자 없이 자신의 필요에 따라 다른 서비스를 호출합니다.

### 17.8.2 트랜잭션과 사가

 마이크로서비스 아키텍처를 구축한 후 뭔가 트랜잭션으로 서비스를 엮어야 할 필요가 생겼다면 십중팔구 설계를 지나치게 세분화한 것입니다. 트랜잭션 경계는 서비스 세분도를 가늠할 수 있는 일반적인 지표 중 하나입니다.

꼭 필요하다면, 사가패턴을 사용할 수 있다.

서비스는 여러 서비스 호출에 대해 중재자 노릇을 하면서 트랜잭션을 조정 합니다. 중재자는 트랜잭션을 구성하는 파트를 하나씩 호출하여 성공/실패 여부를 기록하고 그 결과에 따라 흐름을 조정합니다.

트랜잭션 작업마다 두/언두 로직을 개발하는 식으로 보상 트랜잭션 프레임워크를 구현할 수도 있습니다. 이렇게 하면 트랜잭션 수행 중 조정은 덜 필요하지만, 언두 작업은 두 작업보다 엄청나게 복잡해져 설계, 구현, 디버깅 작업량 역시 2배 이상 증가할 것입니다.

## 17.9 아키텍처 특성 등급

전체 비용과 성능, 단순성 빼고는 다 높다!
