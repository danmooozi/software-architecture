# 컴포넌트 기반 사고

3장에서는 모듈을 관련 코드의 묶음이라고 설명했지만, 아키텍트는 이를 물리적으로 구현한 컴포넌트로 봅니다.  
개발자는 개발 플랫폼에 따라 모듈을 물리적으로 패키징하며, 이와 같이 패키징한 것을 컴포넌트라고 부릅니다.  
예를 들어, 자바의 jar, 닷넷의 dll, 루비의 gem 파일 등이 이에 해당합니다.  
이 장에서는 컴포넌트와 관련된 아키텍처 고려 사항을 다룹니다.

## 8.1 컴포넌트 범위

컴포넌트라는 개념은 다양한 팩터로 세분화하여 적용할 수 있습니다.  
보통 언어마다의 메커니즘을 통해 아티팩트를 묶고 계층화할 수 있습니다.  
가장 단순하게 컴포넌트는 클래스나 함수보다 높은 수준에서 코드를 래핑한 모듈이며, 이를 보통 라이브러리라고 부릅니다.  
라이브러리는 호출부 코드와 동일한 메모리에서 실행되고, 함수 호출 메커니즘을 이용해 통신하며, 일반적으로 컴파일 타임에 의존합니다.

컴포넌트는 아키텍처에서 서브시스템이나 레이어로도 나타나고, 이벤트 프로세서를 위한  배포 가능한 작업 단위로 사용됩니다.  
서비스는 또 다른 종류의 컴포넌트로, 자신의 주소 공간에서 실행되며 TCP/IP, REST 등의 네트워크 프로토콜을 통해 통신합니다.  
마이크로서비스 아키텍처에서 서비스는 독립적이고 배포 가능한 단위를 형성합니다.

반드시 모든 종류의 컴포넌트를 사용할 필요는 없으며, 높은 수준에서 모듈성을 제공하는 것이 더 유용할 수 있습니다.  
특히 마이크로서비스 아키텍처에서는 단순성을 중시하기 때문에, 단순하게 컴포넌트를 설계하는 것이 좋습니다.

## 8.2 아키텍트 역할

아키텍트는 아키텍처 내의 컴포넌트를 정의, 개선, 관리, 통제하는 역할을 수행합니다.  
일반적으로 컴포넌트는 아키텍트가 다루는 최하위 소프트웨어 시스템으로, 컴포넌트는 클래스나 함수로 구성되기 때문에 세부적인 설계 및 구현은 기술 리더나 개발자가 담당합니다.  
아키텍트는 클래스 설계나 세부적인 시스템 설계 결정에 관여해서는 안 되며, 다른 부서가 중요한 결정을 내릴 수 있도록 자율권을 부여해야 합니다.  
아키텍트는 보다 상위 레벨에서 아키텍처를 분할하는 방법을 고민해야 합니다.

### 8.2.1 아키텍처 분할

아키텍트는 다양한 유형의 분할 방식을 선택할 수 있습니다.  
여기에는 각기 다른 트레이드오프를 가진 여러 공통적인 스타일이 있으며, 이 절에서는 최상위 분할이라는 중요한 아키텍처 스타일을 설명합니다.  

레이어드 아키텍처는 레이어를 기반으로 분할된 아키텍처이고, 모듈러 모놀리스는 도메인에 따라 배포 단위를 분할하는 아키텍처입니다.  
이 두 스타일은 아키텍처를 최상위 분할한 결과로, 각각의 최상위 컴포넌트 내부에는 다른 컴포넌트들이 내장되어 있습니다.  
최상위 분할은 아키텍처 스타일과 코드 분할 방법을 결정하는 중요한 관심사입니다.

기술적 최상위 분할은 레이어드 아키텍처처럼 기술적인 능력에 따라 시스템을 구성하는 방식입니다. 
레이어드 아키텍처에서는 시스템 기능을 프레젠테이션, 비즈니스 규칙, 서비스, 퍼시스턴스 등으로 분할합니다.  
이 방식은 퍼시스턴스 코드를 한 레이어에 모아 개발자가 쉽게 찾을 수 있게 합니다.  
레이어드 아키텍처는 모델-뷰-컨트롤러 패턴과 잘 맞고, 이해하기 쉬워서 많은 조직에서 기본 아키텍처로 자리 잡았습니다.

이와 달리 DDD를 기반으로 하는 **모듈러 모놀리스 설계**에서는 독립된 도메인이나 워크플로를 식별하여, 이를 기준으로 아키텍처를 분할합니다.  
도메인 분할 아키텍처에서 별도의 레이어를 두어서 비즈니스 규칙을 위한 중복 컴포넌트를 둘 수도 있지만, 최상위 분할은 도메인을 중심으로 전개됩니다.

최상위 분할 유형은 아키텍처 패턴 간의 주요 차이점 에 해당합니다. 
아키텍트가 컴포넌트를 어떻게 식별할지 결정하는데에도 분할 유형이 큰 영향을 미칩니다.  

기술적 분할을 선택한 아키텍트는 시스템을 프레젠테이션, 비즈니스 규칙, 퍼시스턴스 등 기술적 능력에 따라 구성합니다.  
기술적 관심사의 분리를 통해 디커플링을 달성함으로써, 특정 레이어의 변경이 다른 레이어에 영향을 미치지 않게 합니다. 
이 방식은 코드베이스를 기능별로 구성하여 개발자가 필요한 코드를 쉽게 찾을 수 있게 합니다.   
하지만 많은 소프트웨어 시스템은 여러 기술과 기능을 넘나드는 워크플로를 필요로 하는 경우가 많습니다.   
기술적 분할을 선택한 경우 특정 비즈니스 워크플로의 코드가 여러 레이어에 흩어질 수 있습니다.

반면, 도메인 분할에서는 컴포넌트를 도메인 중심으로 구성하며, 최상위 분할이 도메인에 초점을 맞춥니다.  
프로젝트의 변경 사항은 보통 워크플로 또는 도메인 단위로 발생합니다.  
도메인 분할 아키텍처는 워크플로나 도메인 중심으로 컴포넌트를 구축해 프로젝트에서 자주 발생하는 변경을 더 잘 반영합니다.  
두 스타일 중 어느 것이 더 낫다고 단정할 수는 없으며, 최상위 분할 방식은 아키텍트가 초기에 결정해야 할 중요한 문제입니다.

### 8.2.2 분할 사례 연구: 실리콘 샌드위치

실리콘 샌드위치 카타에서 아키텍트는 컴포넌트를 도출할 때 최상위 분할 방식을 결정해야 합니다.  
첫번째 예시는 도메인 분할 방식으로 설계된 것으로, 도메인/워크플로별로 컴포넌트를 나눴습니다. - 
`Purchase, Promotion, MakeOrder, Manageinventory, Recipes, Delivery, Location`
각 컴포넌트 안에 공통 기능과 로컬 기능을 다루는 서브컴포넌트들을 포함했습니다.  

또 다른 설계에서는 `Common, Local` 로 컴포넌트를 분리해 처리하고, `Purchase, Delivery`  를 워크플로로 처리합니다.  
어느 설계가 더 나은지는 상황에 따라 다르며, 분할 방식에는 각각 장단점이 있습니다.

#### 도메인 분할

**장점**
- 세부 구현보다 비즈니스 기능에 더 가깝게 모델링된다.
- 역 콘웨이 전략을 활용하여 도메인별 다목적팀(cross-functional team)을 구성하기 쉽다.
- 모듈러 모놀리스와 마이크로서비스 아키텍처 스타일에 더 가깝게 맞출 수 있다.
- 메시지 흐름이 문제 영역과 일치한다.
- 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉽다.
**단점**
- 유저 정의 코드가 여기저기 널려 있다.

#### 기술 분할

**장점**
- 커스텀 코드가 명확하게 분리된다.
- 레이어드 아키텍처 패턴에 더 가깝게 맞출 수 있다.
**단점**
- 전역 커플링(coupling)이 더 높다. 
  - 공통 또는 로컬 컴포넌트 중 하나라도 변경되면, 다른 모든 컴포넌트에 영향을 줄 가능성이 높다.
- 개발자가 공통 레이어와 로컬 레이어 양쪽에 도메인 개념을 복제해야 할 수도 있다.
- 일반적으로 데이터 레벨에서 커플링이 높다. 
  - 이러한 시스템은 단일 데이터베이스에 여러 도메인을 포함시키는 방식으로 구성된다.
  - 나중에 분산 시스템으로 전환할 경우 데이터 관계를 분석하기가 어렵다.

## 8.3 개발자 역할

개발자는 **아키텍트와 공동 설계한 컴포넌트를 클래스, 함수, 서브컴포넌트로 세분화**합니다.  
클래스와 함수 설계는 공동 책임이지만 주로 개발자가 담당합니다.  
컴포넌트 설계는 최종판이 아니며, 이터레이션을 통해 점차 개선해야 합니다.  
초기 설계는 초안으로 보고 구현하면서 세부 사항을 다듬어 나가야 합니다.

##  8.4 컴포넌트 식별 흐름

컴포넌트 식별 시에는 먼저 컴포넌트 후보를 도출하고,  피드백을 통해 다듬어가는 과정을 반복하면 좋습니다.  
이 과정에서 아키텍처는 점점 구체화됩니다.  
전체적으로 다음과 같은 단계로 구성되며, 도메인에 따라 보안이나 감사 같은 추가 단계가 필요할 수도 있습니다.

### 8.4.1 초기 컴포넌트 식별

아키텍트는 먼저 최상위 분할 유형을 결정하고, 최상위 컴포넌트를 어디서 시작할지 결정해야 합니다.  
또한 도메인 기능을 컴포넌트와 매핑하여 기능의 위치를 자유롭게 구성합니다.  

### 8.4.2 요구사항을 컴포넌트에 할당

초기 컴포넌트를 식별한 후, 아키텍트는 요구사항이나 유저 스토리를 대입해 적합성을 확인합니다.  
이 과정에서 컴포넌트를 새로 만들거나 통합하고, 역할이 많은 컴포넌트는 분해될 수 있습니다.  
매핑이 완벽할 필요는 없으며, 큰 단위의 기반을 찾아서 이후에 설계를 계속 보완해 나갈 수 있도록 하면 됩니다.

### 8.4.3 역할 및 책임분석

컴포넌트에 스토리를 대입할 때, 요구사항에서 밝혀진 역할과 책임을 검토하고 세분도가 적합한지 확인합니다.  
애플리케이션의 역할과 기능을 모두 고려해 컴포넌트와 도메인의 세분도를 맞추는 것이 중요합니다. 

###  8.4.4 아키텍처 특성 분석

컴포넌트에 요구사항을 대입할 때, 아키텍트는 아키텍처 특성이 컴포넌트 분할과 세분도에 미치는 영향을 고려해야 합니다.  
예를 들어, 유저 입력을 처리하는 시스템 파트는 동시 접속자가 수백명인 경우와 소수인 경우에 아키텍처 특성이 다를 수 있습니다.  
기능적 관점에서만 설계하면 단일 컴포넌트가 도출되지만, 아키텍처 특성을 분석하면 더 세분화된 하위 컴포넌트로 나눌 수 있습니다.

###  8.4.5 컴포넌트 재구성

소프트웨어 설계에서 피드백은 매우 중요하며, 아키텍트는 개발자들과 함께 지속적으로 컴포넌트 설계를 반복해야 합니다.  
예상치 못한 문제들이 발생할 수 있기 때문에, 반복적인 설계 접근이 필수적입니다.  
모든 특이 사례를 사전에 고려하는 것은 불가능하며, 시간이 지날수록 아키텍처와 개발자는 각자의 역할과 기능을 조정할 필요성을 느끼게 됩니다.

## 8.5 컴포넌트 세분도

컴포넌트에서 적절한 세분도를 찾는 것은 아키텍트의 어려운 작업 중 하나입니다.  
너무 잘게 나누면 통신이 많아지고, 너무 크게 나누면 내부 커플링이 증가해 배포와 테스트가 어려워지고 모듈성에도 부정적인 영향을 미칩니다.

## 8.6 컴포넌트 설계

컴포넌트 설계에 정답은 없으며, 다양한 기술과 트레이드오프가 존재합니다.  
아키텍트는 요구사항을 바탕으로 굵직한 주요 구성 요소를 설계해야 합니다.  
이 절에서는 컴포넌트를 발견하는 일반적인 방법과 피해야 할 사항을 다룹니다.

### 8.6.1 컴포넌트 발견

아키텍트는 개발자, 비즈니스 분석가, 도메인 전문가와 협력하여 시스템을 분할하는 초기 컴포넌트 설계를 진행합니다.  
초기 설계의 목표는 아키텍처 특성을 고려해 문제 영역을 큰 덩어리들로 나누는 것입니다.

#### 엔티티 함정

이 패턴은 아키텍트가 요구사항에서 식별된 엔티티를 바탕으로 컴포넌트를 설계하는 경우 발생하며, 이는 실제 아키텍처가 아니라 단순히 데이터베이스 관계를 매핑한 것입니다.  
특히, 데이터베이스 관계를 애플리케이션의 워크플로로 오해하면 안티패턴에 빠지며, 결과적으로 컴포넌트가 너무 크게 나뉘어 개발팀에게 유의미한 가이드를 제공하지 못하게 됩니다.  
컴포넌트는 데이터가 아닌 워크플로에 대한 지식을 바탕으로 설계해야 합니다.

#### 액터/액션 접근법

액터/액션 접근법은 소프트웨어 아키텍트가 요구사항을 컴포넌트에 매핑할 때 사용하는 기법으로, 애플리케이션에서 동작하는 ‘액터’와 이들이 수행하는 ‘액션’을 식별합니다.  
이 접근법은 시스템의 주요 사용자와 그들이 수행하는 작업을 찾아내어 설계에 반영합니다.  
주로 선행 설계(upfront design) 방식과 잘 맞으며, 요구사항에 따라 역할과 액션이 명확한 경우에 효과적입니다.  
모놀리식 및 분산 시스템 등 다양한 시스템에 적용될 수 있습니다.

#### 이벤트 스토밍

이벤트 스토밍은 도메인 주도 설계(DDD)에서 사용하는 컴포넌트 발견 기법으로, 주로 마이크로서비스와 같은 분산 아키텍처에서 활용됩니다.  
이 기법에서는 다양한 컴포넌트가 메시지나 이벤트를 통해 상호 통신한다고 가정합니다.  
따라서 먼저 시스템 내에서 발생하는 이벤트를 파악하고, 이를 바탕으로 이벤트와 메시지 핸들러 중심으로 컴포넌트를 설계합니다.  
이는 최종적 일관성을 지켜야하는 시스템에서 메시지를 정의하는데 도움이 되기 때문에, 마이크로서비스 같은 분산 시스템에서 널리 쓰입니다.

####  워크플로 접근법

워크플로 접근법은 이벤트 스토밍의 대안으로, 도메인 주도 설계(DDD)나 메시징을 사용하지 않는 일반화된 방법입니다.  
이 접근법에서는 먼저 시스템의 핵심 역할을 식별하고, 그 역할이 관여하는 워크플로 유형을 결정한 후, 해당 활동을 바탕으로 컴포넌트를 구축합니다.  
메시지 기반 시스템 구축에 대한 제약이 없어 보다 유연하게 적용됩니다.

## 8.7 컴포넌트 발굴 사례 연구: GGG

액터/액션 접근법은 팀에 특별한 제약이 없고 범용적인 컴포넌트 분할을 고려할 때 적합한 솔루션입니다.  
GGG 카타에서도 이 방법을 적용할 수 있습니다.  
GGG 시스템에는 **입찰자**, **경매인**, 그리고 내부 액션을 수행하는 **시스템**이라는 세 가지 역할이 있으며, 이 역할들이 애플리케이션과 상호작용합니다.  
시스템은 **경매 완료 시 결제 시스템을 트리거**하는 등 **이벤트가 발생하는 시점을 식별해 대응**합니다.

각 역할의 초기 액션 세트는 다음과 같이 정리할 수 있습니다.

- **Bidder**: 라이브 동영상 스트림과 라이브 입찰 스트림을 보고 입찰을 한다.
- **Auctioneer**: 라이브 입찰을 시스템에 입력하고, 온라인 입찰을 수신하며, 아이템을 팔린 것으로 표시한다.
- **System**: 경매를 시작하고, 결제를 처리하고, 입찰자 활동을 추적한다.

이 액션들을 바탕으로 GGG의 초기 컴포넌트 세트를 구축할 수 있습니다.

- **Videostreamer**  
  - 유저에게 라이브 경매를 스트리밍한다.
- **Bidstreamer**  
  - 입찰이 발생하면 즉시 유저에게 스트리밍한다. 
  - VideoStreamer와 Bidstreamer는 입찰자에게 읽기 전용 경매 뷰를 제공한다.
- **BidCapture**  
  - 경매인, 입찰자 양쪽에서 입찰을 캡처한다.
- **BidTracker**  
  - 입찰을 추적하는 기록 시스템 역할을 한다.
- **AuctionSession**  
  - 경매 세션을 시작/종료한다. 
  - 입찰자가 경매를 끝내면 결제를 처리하고 그 결과를 입찰자에게 알려주는 등 후속 조치를 한다.
- **Payment**  
  - 신용카드 결제를 처리하는 서드파티 결제 프로세서

초기 설계에서는 단일한 BidCapture 컴포넌트가 입찰자와 경매인의 입찰을 동일하게 처리하도록 설계되었습니다.  
하지만 경매인은 입찰자와 다른 확장성, 탄력성, 신뢰성, 가용성 수준이 요구됩니다.  
특히 경매인이 접속 문제를 겪으면 큰 문제가 될 수 있기 때문에, 경매인에 대해서는 신뢰성, 가용성 등의 아키텍처 특성을 더 확실하게 보장해야 합니다.  
따라서 BidCapture 컴포넌트를 입찰자와 경매인의 경우로 두 개의 컴포넌트(BidCapture, Auctioneercapture)로 나누어, 각 시스템 파트 마다다른 수준으로 아키텍처 특성을 지원할 수 있도록 해야 합니다.

그림 8-11

새로운 구조에서는 AuctioneerCapture 컴포넌트가 신설되어, 라이브 입찰을 스트리밍 하는 BidStreamer와 입찰 스트림을 관리하는 BidTracker로 정보를 업데이트 합니다.  
BidTracker는 BidCapture, AuctioneerCapture 등의 통해 여러 스트림을 통해 경매인과 입찰자들의 정보들을 통합합니다.  

## 8.8 아키텍처 퀀텀 딜레마: 모놀리식이냐, 분산 아키텍처냐

초기 컴포넌트 설계를 마친 후에는 모놀리식 아키텍처로 갈지 분산 아키텍처로 갈지 결정해야 합니다.  
모놀리식 아키텍처는 하나의 배포 단위로 단일 데이터베이스에 접속해 모든 시스템 기능을 포함하지만, 분산 아키텍처는 여러 서비스로 나뉘어 네트워킹을 통해 통신합니다.  
분산 아키텍처는 배포 단위가 잘게 나뉘어져 있고, 각 서비스가 별도의 개발팀, 릴리즈 주기를 가지며 독립적으로 운영됩니다.

아키텍처 스타일은 각기 다른 트레이드오프를 가지지만, 근본적인 결정은 아키텍처 퀀텀 수에 따라 달라집니다.  
단일 퀀텀으로 가능한 시스템은 모놀리식 아키텍처가 적합하지만, GGG 시스템처럼 각 컴포넌트의 아키텍처 특성이 다르면 분산 아키텍처가 필요합니다.  
예를 들어, VideoStreamer와 Bidstreamer는 읽기 전용 경매 뷰를 제공하며, 이를 대용량 업데이트와 함께 처리할 필요가 없습니다.  
아키텍처 퀀텀을 사용하면 초기 설계에서 모놀리식과 분산 아키텍처 중 구조를 결정하는 데 도움이 됩니다.

