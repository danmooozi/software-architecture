# 아키텍처 특성의 측정, 거버넌스

## 6.1 아키텍처 특성 측정

아키텍처 특성을 정의할 때 발생하는 문제는 크게 세 가지로 요약할 수 있습니다.

1. **모호한 의미**: 아키텍처 특성은 의미가 모호하기 때문에, ‘민첩성’이나 ‘배포성’ 같은 용어의 의미가 업계나 상황에 따라 다르게 해석됩니다.
2. **정의의 다양성**: 중요한 특성인 성능과 같은 개념조차도 같은 조직 내 부서별로 정의가 일치하지 않는 경우가 많아, 개발자, 아키텍트, 운영자 간 원활한 소통을 위해서는 정의를 통일해야 합니다.
3. **복잡성**: 아키텍처 특성은 보통 여러 작은 특성들로 구성됩니다. 예를 들어 민첩성은 모듈성, 배포성, 시험성 등의 특성으로 세분화 될 수 있습니다.

아키텍처 특성의 모호성, 정의의 다양성, 복잡성 문제는 아키텍처 특성을 명확하고 객관적으로 정의함으로써 해결할 수 있습니다. 조직 전체가 이에 동의하면 공통의 언어를 확립할 수 있으며, 복합적인 특성도 세분화해 측정 가능한 특성으로 정의할 수 있습니다.

### 6.1.1 운영적 측정

아키텍처 특성 중 성능과 확장성은 비교적 정확하게 측정할 수 있지만, 팀의 목표에 따라 여전히 해석이 다를 수 있습니다. 예를 들어, 평균 응답 시간을 측정할 때 일부 요청의 처리 시간이 매우 길다면, 단순 평균만으로는 특이점을 발견하기 어려울 수 있습니다. 따라서 최대 응답 시간도 함께 측정해야 이러한 특이점을 잡아낼 수 있습니다.

수준 높은 팀은 달성하기 어려운 성능 목표를 설정하는 대신, 통계 분석을 통해 정의된 목표를 사용합니다. 예를 들어, 비디오 스트리밍 서비스 업체는 시간에 따른 추이를 측정하고 통계 모델을 수립한 후, 실시간 메트릭이 예측 범위를 벗어나면 알림을 보내는 방식으로 확장성을 모니터링할 수 있습니다. 이 과정이 실패하면 모델이 부정확하거나 시스템에 문제가 있음을 실시간으로 알 수 있습니다.

도구의 발전과 이해도 향상으로 팀이 측정할 수 있는 아키텍처 특성도 빠르게 진화하고 있습니다. 최근에는 최초 콘텐츠 렌더링과 최초 CPU 유휴 상태와 같은 메트릭에 성능 예산을 집중하여, 모바일 기기 사용자의 성능 문제를 해결하는 데 주력하는 것도 가능합니다. 기기와 목표, 능력 등이 변화함에 따라 팀은 새로운 측정 방법을 찾아 발전해 나갑니다.

### 6.1.2 구조적 측정

성능처럼 목표치가 명확하지 않은 메트릭도 있으며, 모듈성 같은 내부 구조 관련 특성이 대표적입니다. 아직 내부 품질을 평가하는 종합적인 메트릭은 없지만, 여러 메트릭과 도구를 활용하면 코드 구조의 중요한 부분을 분석해 볼 수 있습니다.

대표적으로 순환 복잡도(CC)는 코드의 복잡도를 측정하는 메트릭으로, 함수, 메서드, 클래스 또는 애플리케이션 수준에서 복잡도를 객관적으로 나타냅니다.  
CC는 그래프 이론을 적용하여 결정점(예: if문)으로 실행 경로의 수를 계산합니다.  
결정점이 없는 함수의 CC는 1이고, 조건 분기가 하나 추가될 때마다 CC 값이 증가합니다.  
CC를 계산하는 기본 공식은 **CC = E - N + 2**이며, 여기서 N은 노드(코드 라인), E는 간선(결정점)입니다.  
함수 간 연결된 컴포넌트까지 고려한 일반 공식은 **CC = E - N + 2P**입니다(P는 연결된 컴포넌트 수).  
다음의 코드는 노드가 5개, 간선이 4개로, 순환복잡도는 `5 - 4 + 2 = 3` 이다.

```java
public int decision(int c1, int c2) {
    if (c1 < 100) {
        return 0;
    } else if (c1 + c2 > 500) {
        return -1;
    } else {
        return 1;
    }
}
```

아키텍트와 개발자는 모두 복잡한 코드가 **코드 스멜**로 이어진다는 사실에 동의합니다.  
복잡한 코드는 모듈성, 테스트 용이성, 배포성 등 중요한 코드 특성을 저해합니다.  
복잡도가 증가하는 것을 주의 깊게 관리하지 않으면, 결국 복잡도가 코드베이스를 장악하게 됩니다.

순환 복잡도(cyclomatic complexity)가 어느 정도여야 적절한지는 문제의 복잡도에 따라 다릅니다.  
복잡한 문제는 복잡한 함수로 이어질 수 있지만, 복잡도가 높은 이유가 문제 자체인지, 코딩 품질이 낮아서인지, 코드 분할이 부족해서인지 분석이 필요합니다.  
큰 메서드는 작은 로직으로 나누어 복잡도를 분배하는 것이 좋습니다.  
일반적으로 CC가 10 이하이면 괜찮다고 보지만, 5 이하가 더 좋은 코드로 여겨집니다.  
테스트 주도 개발(TDD)은 자연스럽게 작고 덜 복잡한 메서드를 만들게 하며, 이를 통해 CC 값도 낮아집니다.

### 6.1.3 프로세스 측정

소프트웨어 개발 프로세스와 관련된 아키텍처 특성들도 있습니다.  
대표적으로 **민첩성**은 프로세스와 연관된, 시험성, 배포성 등으로 나눌 수 있는 복합적인 특성입니다.

시험성은 코드 커버리지 도구로 측정할 수 있는 특성입니다.  
다만 커버리지가 높다고 항상 코드의 정확성을 보장하는 것은 아니기 때문에, 정확한 의도와 사고를 바탕으로 assertion을 수행하는지도 살펴봐야 합니다.  
배포성은 배포 성공률, 소요 시간, 발생한 이슈 등 다양한 메트릭으로 측정할 수 있습니다.  
각 팀은 자신에게 맞는 메트릭을 준비해야 하며, 이 메트릭들은 팀의 목표와 우선순위에 사용됩니다.

위에서 살펴본 민첩성과 관련된 요소는 소프트웨어 개발 프로세스와 연관될 뿐만 아니라 아키텍처 구조에도 영향을 미칠 수 있습니다.  
배포 용이성과 시험성이 우선순위라면, 아키텍트는 모듈성 및 격리성을 높이는 방향으로 아키텍처를 설계할 것입니다.  
이는 아키텍처 특성이 구조를 주도하는 좋은 예로, 프로젝트의 모든 요소가 이 기준을 만족하면 아키텍처 특성을 충족하게 됩니다.  
따라서 아키텍트는 이러한 특성을 고려해 설계 결정을 내려야 합니다.

## 6.2 거버넌스와 피트니스 함수

아키텍트가 아키텍처 특성을 확정하고 우선순위를 정한다고 하더라도, 개발자들이 이를 잘 따를지 확신하기 어렵습니다.  
특히 모듈성과 같은 특성은 중요하지만 긴급하지 않을 수 있습니다.  
아키텍트는 아키텍처 특성의 우선순위를 유지하기 위해 **거버넌스 메커니즘**을 마련해야 합니다.

### 6.2.1 아키텍처 특성 관리

거버넌스(governance)는 '이끌다'라는 그리스어에서 유래된 말로, 아키텍트의 중요한 역할 중 하나입니다.  
아키텍처 거버넌스는 모든 소프트웨어 개발 프로세스를 포괄하며, 소프트웨어 품질 보장 업무도 포함됩니다.  
자동화 도구와 데브옵스 등의 발전으로 소프트웨어 개발 생태계의 내부 역량이 많이 개선되었으며, 아키텍처 거버넌스를 통해 지속적으로 생태계가 발전하고 있습니다.

### 6.2.2 피트니스 함수

피트니스 함수는 아키텍처 거버넌스를 자동화하는 기법 중 하나로 소개되고 있습니다.  
**아키텍처 피트니스 함수**는 특정 아키텍처 특성(또는 특성들의 조합)의 무결성을 객관적으로 평가하는 메커니즘을 말합니다.  
피트니스 함수는 새로운 프레임워크가 아니라, **기존 도구들을 새로운 시각으로 활용하는 것**에 가깝습니다.  
다양한 기법으로 아키텍처 특성을 검증할 수 있으며, 메트릭, 모니터링, 단위 테스트, 카오스 엔지니어링 등 여러 검증 메커니즘과 중첩될 수 있습니다.

#### 순환 의존성

**순환 의존성**은 모듈성에 해를 끼치는 중요한 문제입니다.  
모듈성이 유지되지 않으면 코드베이스 구조에 문제가 발생하므로 관리가 필수적입니다.  
특히 IDE에서 지원하는 자동 임포트 기능을 남용하다 보면 모듈성을 해치는 경우가 많습니다.  
개발자가 무심코 클래스나 컴포넌트를 자주 임포트하면 컴포넌트 간에 서로 참조가 일어나서 모듈성이 떨어지고, 커플링이 증가하면서 아키텍처가 안티패턴에 빠지게 됩니다.  
코드 리뷰를 통해 이를 방지할 수 있지만, 리뷰를 하는 것은 개발 주기 상 마지막 부분이기 때문에 문제를 고치기에는 이미 늦고 비효율적입니다.

그 대신 **피트니스 함수**를 사용해 순환 참조 여부를 자동으로 발견하면 이러한 문제를 효괴적으로 예방할 수 있습니다.

아래 예시에서는 JDepend12라는 메트릭 도구를 사용해 자바 패키지 간 의존성을 체크하며, 프로젝트에 순환 참조가 있으면 테스트가 실패하게 됩니다.

```java

public class CycleTest {
    private JDepend jdepend;

    @BeforeEach
    void init() {
        jdepend = new JDepend();
        jdepend.addDirectory("/path/to/project/persistence/classes");
        jdepend.addDirectory("/path/to/project/web/classes");
        jdepend.addDirectory("/path/to/project/thirdpartyjars");
    }

    @Test
    void testAllPackages() {
        Collection packages = jdepend.analyze();
        assertEquals("Cycles exist", false, jdepend.containsCycles());
    }
}
```

이를 프로젝트의 지속적 빌드 과정에 포함시켜 개발 중 순환 참조를 방지할 수 있습니다.  
이와 같이 피트니스 함수를 사용하면 소프트웨어 개발에서 중요한 설계 원칙을 지킬 수 있습니다.

#### ‘메인 시퀀스로부터의 거리’ 피트니스 함수

JDepend를 통해 ‘메인 시퀀스로부터의 거리’ 메트릭을 확인하여, 수용 가능한 임계치를 벗어나면 테스트를 실패하도록 설정할 수 있습니다.

```java
@Test
void AllPackages() {
    double ideal = 0.0;
    double tolerance = 0.5; // 프로젝트마다 값이 다름
    Collection packages = jdepend.analyze();
    Iterator iter = packages.iterator();

    while (iter.hasNext()) {
        JavaPackage p = (JavaPackage) iter.next();
        assertEquals("Distance exceeded: " + p.getName(),
                     ideal, p.distance(), tolerance);
    }
}
```

피트니스 함수 설계 시에는 개발자와 아키텍트 간의 협력이 중요합니다.  
아키텍트는 개발자가 이해할 수 없는 복잡한 피트니스 함수를 만들지 말아야 하며, 개발자가 피트니스 함수의 목적을 충분히 이해할 수 있도록 설명해야 합니다.  
최근 개발된 ArchUnit 같은 도구는 JUnit 기반에서 더 정교하고 특화된 형태로 모듈성 테스트를 지원하며, 아키텍트가 모듈성에 특화된 테스트를 작성하는데 도움을 줍니다.

예를 들어 레이어드 모놀리스 아키텍처를 설계했다고 해봅시다.  
이 때 일부 개발자들은 성능 같은 로컬 이슈를 우선시하거나 아키텍처의 중요성을 간과하여 레이어 규칙을 위반할 수 있습니다.  
이를 방지하기 위해 ArchUnit 의 피트니스 함수를 통해 레이어 규칙을 자동으로 검사하고 위반을 방지할 수 있습니다.

```java
layeredArchitecture()
    .layer("Controller").definedBy("..controller..")
    .layer("Service").definedBy("..service..")
    .layer("Persistence").definedBy("..persistence..")

    .whereLayer("Controller").mayNotBeAccessedByAnyLayer()
    .whereLayer("Service").mayOnlyBeAccessedByLayers("Controller")
    .whereLayer("Persistence").mayOnlyBeAccessedByLayers("Service");
```

넷플릭스의 Chaos Monkey와 Simian Army는 피트니스 함수의 응용 사례 중 하나입니다.  
적합성 멍키는 넷플릭스 아키텍트가 프로덕션에서 강제한 거버넌스 규칙을 검사하며, 보안 멍키는 서비스의 보안 취약점을 점검합니다.  
문지기 멍키는 더 이상 사용되지 않는 서비스 인스턴스를 찾아 제거하는 역할을 합니다.  
이를 통해 넷플릭스는 진화적인 아키텍처를 유지하며, 새로운 서비스로 쉽게 이전할 수 있는 환경을 갖출 수 있었습니다.
