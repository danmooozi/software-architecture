# CHAPTER 1 서론

> 이 책의 부제는 '엔지니어링 접근 방식 engineering approach' 입니다.

소프트웨어 아키텍트는 다른 직업에 비해 커리어패스가 분명하지 않은 이유

1. 직업 자체에 대한 명확한 정의가 아직도 없습니다.
2. 방대한 분야를 포괄하며 업무 범위가 계속 넓어지고 있습니다.
   1. 모듈성, 컴포넌트, 패턴 등의 기술적인 부분 -> 마이크로서비스
3. 개발 생태계는 워낙 빠르게 발전하는 분야이고 소프트웨어 아키텍처는 끊임없이 변합니다.
4. 관련 자료가 대부분 역사적인 연관성을 강조합니다.

소프트웨어 아키텍트는 이렇게 끊임없이 변하는 생태계 안에서 뭔가 결정을 내리는 사람들입니다. 아키텍트가 내린 결정은 대부분 그들이 그렇게 결정한 당시 환경에 기인한 것입니다. 가령, 20세기 아키텍처의 주요 목표 중 하나는 최대한 효율적으로 리소스를 공유하여 사용하는 것이었는데, 그 시절에는 모든 인프라가 가격이 비쌌으니 당연합니다.

## 1.1 소프트웨어 아키텍처란?

시스템 청사진(blueprint), 시스템 개발의 이정표(roadmap).

소프트웨어 아키텍처는 아키텍처 특성, 아키텍처 결정, 설계 원칙, 시스템의 구조로 구성됩니다.

시스템의 구조란 시스템이 구현된 아키텍처 스타일들의 종류(마이크로서비스, 레이어드, 마이크로커널 같은)를 말합니다.

```text
마이크로서비스란? 마이크로서비스 또는 마이크로서비스 아키텍처는 하나의 애플리케이션이 느슨하게 결합되고 독립적으로 배포 가능한 여러 개의 작은 구성 요소 또는 서비스로 구성된 클라우드 네이티브 아키텍처 방식입니다.

레이어드 아키텍처는 소프트웨어를 여러 개의 레이어 / 논리적인 논리적 계층으로 구분한 아키텍처를 의미합니다. 이는 시스템을 모듈화하여 유지보수성, 확장성, 유연성을 향상시키는 데에 중점을 둡니다.
현대 어플리케이션에서는 프레젠테이션 계층, 데이터 액세스 계층 말고도 다양한 인터페이스를 필요로 하며, 어플리케이션을 호출하는 다양한 시스템의 유형과 어플리케이션과 상호작용하는 다양한 저장소가 존재하여 단방향 계층 구조에서는 이러한 점을 지원하기가 어렵습니다.

마이크로커널 아키텍처는 코어 시스템과 플러그인 컴포넌트로 이루어져있고, 독립적인 실행을 보장하는 플러그인 컴포넌트를 코어 시스템에 끼울 수 있는 형태. 모놀리식에서 많이 사용.
```

아키텍처 특성은 시스템의 기능과 직교하는 시스템의 성공 기준을 결정합니다. 기용성, 신뢰성, 시험성, 확장성, 보안, 민첩성, 내고장성, 탄력성, 복구성, 성능, 배포성, 학습성.

아키텍처 결정(decision)은 시스템 구축에 필요한 규칙들을 정한 것입니다. 아키텍처 결정은 시스템의 제약조건을 형성하며, 개발자가 해도 되는 것과 하지 말아야 할 것을 알려줍니다. 레이어드 아키텍처에서 프레젠테이션 레이어가 데이터베이스 레이어를 호출하지 못하는 것을 예로 들 수 있음.

설계 원칙은 가이드라인입니다. 예를 들어, 마이크로서비스 아키텍처의 성능 향상을 위해 서비스 간 통신은 비동기 메시징을 활요해야 한다고 기술하는 것. 서비스 간 통신에 관한 모든 조건과 구현 방안을 아키텍처 결정으로 다룰 수 없기에 특정 환경에서 개발자가 더 적합한 통신 프로토콜을 선택할 수 있도록 우선 권장하는 방법에 관한 가이드를 설계 원칙으로 제공하는 것입니다.

## 1.2 아키텍트에 대한 기대치

역할, 직책, 직무에 상관없에 소프트웨어 아키텍트에게 바라는 핵심적인 요구사항은 다음 여덟가지로 정리할 수 있습니다.

* 아키텍처 결정을 내린다.
* 아키텍처를 지속적으로 분석한다.
* 최신 트렌드를 계속 유지한다.
* 아키텍처 결정의 컴플라이언스를 보장한다.
* 다양한 기술과 경험에 노출된다.
* 대인 관계 기술이 뛰어나다.
* 정치를 이해하고 처세를 잘한다.

### 1.2.1 아키텍처 결정을 내린다

첫 번째 요구사항의 키워드는 '가이드'입니다. 아키텍트는 기술 선택을 가이드하는 사람이지 정해주는 사람이 아닙니다. 프론트 웹 개발용 리액티브 기반의 프레임워크를 사용하도록 기술 지도를 하고 앵귤러, 엘름, 리액트, 뷰와 같은 리액티브 기반의 웹 프레임워크 중 하나를 선정할 수 있도록 가이드합니다.

아키텍트는 확장성, 성능, 가용성 등의 아키텍처 특성을 수호하기 위해 특정한 기술을 결정해야 할 때도 있는데, 이런 경우에는 그 기술을 지정한 행위 자체를 아키텍처 결정이라고 할 수 있습니다.
```text
아키텍처 결정(decision)은 시스템 구축에 필요한 규칙들을 정한 것입니다. 아키텍처 결정은 시스템의 제약조건을 형성하며, 개발자가 해도 되는 것과 하지 말아야 할 것을 알려줍니다. 레이어드 아키텍처에서 프레젠테이션 레이어가 데이터베이스 레이어를 호출하지 못하는 것을 예로 들 수 있음.
```

### 1.2.2 아키텍처를 지속적으로 분석한다

3년 이전에 정의한 아키텍처가 지금도 얼마나 현실성 있는지 평가하는 아키텍처 역동성에 관한 요구사항입니다. 대부분의 아키텍처 구조는 쇠락하는 양상을 보이며, 특히 성능, 가용성, 확장성 등의 필수 아키텍처 특성에 영향을 미치는 코드를 개발자가 작성하거나 설계를 변경할 때 이런 증상이 나타납니다.

### 1.2.3 최신 트렌드를 계속 따라간다

개발자는 자신이 매일 사용하는 기술을 항상 갈고 닦아 최신 상태로 유지해야 계속 일을 할 수 있습니다. 아키텍트는 최신 기술과 업계 트렌드를 따라가야 합니다. 24장에 자세히 다룹니다.

### 1.2.4 아키텍처 결정의 컴플라이언스를 보장한다

컴플라이언스 보장이란, 아키텍트가 정의하고 문서화하여 전달한 아키텍처 결정과 설계 원칙들을 개발팀이 제대로 준수하고 있는지 지속적으로 확인한다는 뜻입니다.

프레젠테이션 레이어는 단순한 데이터베이스 호출이라도 반드시 모든 아키텍처 레이어를 거쳐야 통신이 가능합니다. 개발자가 불만을 품고 데이터베이스에 직접 액세스하여 성능 향상을 꾀하려고 합니다. 하지만 아키텍트가 그렇게 결정한 데에는 '변경을 다스리겠다'는 중요한 의도가 깔려 있는 것입니다. 레이어를 분리함으로써 프레젠테이션 레이어에 영향을 미치지 않고 데이터베이스를 변경할 수 있는 틀을 만든 거죠. 위반 사례가 곳곳에 발생한 결과, 아키텍처는 필요한 아키텍처 특성을 준수할 수 없게 되고 앱이나 시스템이 기대한 것처럼 동작하지 않겠죠.

### 1.2.5 다양한 기술과 경험에 노출된다

### 1.2.6 비즈니스 도메인 지식을 보유한다

### 1.2.7 대인 관계 기술이 뛰어나다

### 1.2.8 정치를 이해하고 처세를 잘한다

아키텍트가 내린 모든 결정은 사람들의 반발에 부딪히기 마련입니다. 아키텍처 결정을 실천하려면 당연히 시간과 비용이 들여야 하므로 제품 오너, 프로젝트 관리자, 비즈니스 이해 담당자들의 뭇매를 맞게 될 수밖에 없죠. 또 자기들의 방식이 더 낫다고 주장하는 개발자들의 공격도 피할 수 없습니다. 아키텍트는 회사에서 정치를 잘하면서 대부분의 결정을 사람들이 수용하도록 기본적인 협상 기술을 발휘해야 합니다.

## 1.3 아키텍처의 교차점 그리고...

10년 전만 해도 아키텍처와 운영의 고나계는 보통 공식적인 계약으로 한정됐고 번거로운 행정 절차가 뒤따랐습니다. 하지만 이제 마이크로서비스 같은 아키텍처에서는 예전에 순전히 운영 관심사였던 부문을 자유롭게 넘나들 수 있게 됐습니다. (가동 시간, 확장성, 응답성 등..)

### 1.3.1 엔지니어링 프랙티스

프로세스는 팀을 어떻게 구성하고 관리할지, 회의는 어떻게 하고 워크플로 조직은 어떻게 운영할지 등 사람을 조직하고 상호작용하는 총체적인 기법입니다. 소프트웨어 엔지니어링 프랙티스는 프로세스와 무관하게 가시적이고 반복 가능한 혜택을 주는 실천론입니다. 예컨대, CI는 특정 프로세스에 의존하지 않는 검증된 엔지니어링 프랙티스입니다.

엔지니어링 프랙티스에 집중하는 것은 중요합니다. 첫째, 소프트웨어 개발 분야는 보다 성숙한 다른 엔지니어링 체계에 있는 많은 특성들이 빠져있습니다. 둘째, 소프트웨어 개발의 치명적 약점 중 하나는 추정입니다. 얼마나 오래 걸리고, 얼마나 많은 리소스가 필요하고, 얼마나 많은 비용이 들어갈지 내다봐야 합니다. 알려지지 않은 미지의 것들 때문에 추정은 더 어렵습니다.-

알려지지 않은 미지의 것들을 설계할 수 없기 때문에 빅 디자인 업 프론트(일단 설계부터 확실하게!) 방식으로 진행하기 어렵습니다. 이 책의 저자 중 한 사람인 마크가 한 말입니다. '모든 아키텍처는 알려지지 않은 미지의 것들 때문에 자꾸 되풀이되는데, 애자일은 단지 이것을 인지해서 더 빨리 수행하는 것이다.' 그러므로 프로세스는 아키텍처와 거의 분리되어 있지만, 소프트웨어 아키텍처의 속성상 반복적인 프로세스가 잘 맞습니다.

### 1.3.2 운영/데브옵스

과거에는 운영은 외주를 맡기는 경우가 많았고, 운영을 마음대로 할 수 없다는 전제 하에 제약 위주로 방어적으로 구축됐습니다. 그러다가 운영 문제를 아키텍처와 결합한 새로운 형태의 아키텍처를 실험하다가 마이크로 서비스를 만들게 되었습니다.

### 1.3.3 프로세스

소프트웨어 아키텍처는 소프트웨어 개발 프로세스에 거의 직교하는 공리가 있습니다. 소프트웨어를 개발하는 개발팀의 프로세스는 소프트웨어 아키텍처 여러 파트에 영향을 미칩니다. 일례로, 지난 수십 년 간 소프트웨어의 본질 때문에 애자일 개발 방법론을 도입한 회사들이 참 많습니다.

재구성은 애자일 방법론의 진면목을 볼 수 있는 중요한 아키텍처 분야 중 하나입니다. 예를 들어, 일단 알기 쉽고 빨리 착수 가능한 모놀리식 아키텍처로 시작했지만 이제는 더 현대적인 아키텍처로 이동해야 한다고 생각하는 것입니다. 애자일 방법론은 피드백 루프가 더 촘촘하고 스트랭글러 패턴, 기능 토글 등의 기법 덕분에 기획만 가득한 프로세스보다 이런 종류의 변경이 더 잘 지원됩니다.
```text
스트랭글러 패턴
레거시 시스템을 점진적으로 교체하여 레거시 시스템을 단계적으로 페이드아웃한다.
레거시 시스템의 일부를 새로운 애플리케이션이나 서비스로 교체한다.
일정 기간이 지난 후, 대체된 레거시 기능을 제거한다.
위의 두 작업을 반복한다.

기능 토글
Feature Toggle은 코드를 수정하지 않고 시스템의 동작을 바꿀 수 있는 기술이다.
토글이 켜져 있을 때에는 새로운 피쳐를 활성화하고 꺼져 있을 때에는 기존/레거시 피쳐를 활성화한다.
토글 포인트(Toggle Point)를 토글 라우터(Toggle Router)에서 분리한다.
토글 설정(Toggle Configuration)은 특정 저장소에 의존하지 않는다.
토글 설정(Toggle Configuration)을 코드 배포 없이 동적으로 설정할 수 있다.
사용하지 않는 토글은 바로 제거한다.
```

### 1.3.4 데이터

우리는 이 책에서 외부 스토리지의 존재와 의존성을 무시하지 않고, 특히 아키텍처 퀀텀(3장)과 아키텍처 운영 문제를 논할 때 데이터베이스처럼 중요한 외부 관심사는 반드시 포함할 것입니다.

## 1.4 소프트웨어 아키텍처 법칙

> *소프트웨어 아키텍처 제 1법칙*
> 소프트웨어 아키텍처의 모든 것은 다 트레이드오프다.

> *소프트웨어 아키텍처 제 2법칙*
> '어떻게'보다 '왜'가 더 중요하다.

우리는 앞으로 이 책에서 아키텍트가 트레이드오프를 감안하여 왜 그런 결정을 하는지, 그리고 중요한 결정을 포착하는 멋진 기법을 중점적으로 살펴보고자 합니다(19.3절).
