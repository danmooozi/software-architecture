# 모듈성
플랫폼마다 코드 재사용 메커니즘은 다르지만, 연관된 코드를 모듈로 묶는 방법은 모두 지원하고 있다.  
모듈성은 시스템을 구조적으로 유지하고 복잡성을 줄이는 데 중요한 역할을 한다.  
모듈성을 유지하는 것은 아키텍트의 주요한 역할 중 하나이며, 아키텍처의 암묵적인 특성으로도 여겨진다.  
즉 모듈성을 공식적으로 요구하지 않더라도, 아키텍처에서 모듈성을 지켜서 코드베이스의 질서와 일관성을 유지하는 것은 필수적이다.



객체 지향 언어 이후에는 다양한 프로그래밍 체계가 존재하고 있다.  
초기에는 GOTO 문의 비선형적인 흐름으로 인해 코드를 이해하고 디버깅하기 어려워졌음을 지적되었고, **구조적 프로그래밍 언어**가 발전하면서 코드를 논리적으로 연결하는 방법을 고민하게 되었다.  
이후 **모듈러 언어**인 파스칼, 모듈라 등에서 모듈을 통해 코드를 묶는 방식이 제시되었고, 그 후에는 **객체 지향 언어**의 인기가 높아졌다.  
하지만 이후부터는 다양한 패러다임을 지원하는 방향으로 각 프로그래밍 언어가 발전하게 되었다.  
대표적으로 자바는 패키지를 통한 모듈화, 객체 지향, 함수형 패러다임 등 다양한 패러다임을 지원하기 위해 여러 호환성 기능을 포함하고 있으며, 각 프로그래밍 스타일에 맞춘 규칙과 기능들이 존재한다.

**모듈성**이라는 개념은 논리적인 구분이며, 물리적인 구분과는 다르다.  
예를 들어 **모놀리식 애플리케이션**의 경우 많은 클래스를 한 위치에 묶어도 문제는 없지만, 아키텍처를 재구축할 때는 커플링된 구조가 걸림돌이 될 수 있다.  
보통 물리적인 구조는 플랫폼에 함축되어 있거나 강데된 경우가 많으나, 모듈성의 논리적인 구분은 이와 별개이다.  
**닷넷 플랫폼**에서는 네임스페이스라는 논리적 구분을 위한 개념이 있으며, 개발자는 완전 정규화 명칭(Fully Qualified Name, FQN)을 사용해 소프트웨어 리소스를 구분한다.  
(FQN: 패키지나 네임스페이스를 명칭에 포함하여, 각 리소스의 이름이 중복되지 않게 한 것)
또한 자바의 패키지 구조에서는 물리적인 파일 구조에 네임스페이스가 반영되어 있다.

```dotnet

// 첫 번째 네임스페이스 정의
namespace Company.Project.ModuleA
{
    public class MyClassA
    {
        public void PrintMessage()
        {
            Console.WriteLine("Hello from ModuleA!");
        }
    }
}

// ==============================

using Company.Project.ModuleA;

public class Program
{
    public static void Main(string[] args)
    {
        // ModuleA의 클래스 사용
        MyClassA classA = new MyClassA();
        classA.PrintMessage(); // 출력: Hello from ModuleA!
    }
}

```
### 응집
응집(cohesion)은 모듈 내의 각 구성 요소가 얼마나 밀접하게 연관되어 있는지를 나타냅니다.  
응집이 높을수록 모듈이 더 효과적으로 기능하며, 잘게 나누려 할 경우 오히려 가독성과 효율성이 떨어질 수 있습니다.  
응집도의 종류에는 다음과 같은 항목들이 있으며, 이 중 기능적 응집이 가장 바람직하고, 동시적 응집이 가장 바람직하지 않습니다.

1. 기능적 응집(functional cohesion): 모듈의 모든 부분이 동일한 기능을 위해 밀접하게 연관됨.
2. 순차적 응집(sequential cohesion): 한 모듈의 출력이 다른 모듈의 입력으로 사용되는 형태.
3. 소통적 응집(communication cohesion): 모듈들이 데이터를 주고받으며 상호작용.
4. 절차적 응집(procedural cohesion): 모듈들이 정해진 순서대로 실행됨.
5. 일시적 응집(temporal cohesion): 시점에 따라 관련된 작업들이 묶여 있는 상태.
6. 논리적 응집(logical cohesion): 동일한 논리적 분류의 작업들이 모듈에 포함되지만, 서로 다른 기능 수행. (ex - StringUtils)
7. 동시적 응집(coincidental cohesion): 모듈의 구성 요소들이 별다른 연관성 없이 묶여 있는 상태. 가장 낮은 응집도.

응집은 커플링보다 덜 정확한 메트릭이므로, 모듈의 응집도는 아키텍트의 재량에 따라 달라질 수 있습니다.  
예를 들어, 고객 관리 모듈에 주문 관련 작업들을 포함시킬 수 있지만, 이들을 별도의 주문 관리 모듈로 분리할 수도 있습니다.  
둘 중 어떤 방식이 적합한지는 상황에 따라 다릅니다.  
다음과 같은 사항들이 고려될 필요가 있습니다.

- 주문 관리 작업이 적은지 - 적을 경우 고객 관리 모듈에 포함하는 것이 효율적일 수 있습니다.
- 고객 관리 모듈이 계속 확장될 가능성이 있는지.
- 주문 관리 모듈이 고객 정보를 얼마나 많이 필요로 하는지.

이러한 질문들은 소프트웨어 아키텍처에서 트레이드오프 분석의 중요한 부분입니다.  
Chidamber와 Kemerer는 객체 지향 소프트웨어 시스템의 구조를 측정하기 위한 메트릭 세트인 Chidamber and Kemerer object-oriented metrics suite를 개발했으며, 이는 순환 복잡도 및 다양한 커플링 정도를 측정하는 데 유용합니다.

그 중 LCOM(Lack of Cohesion of Methods)은 공유 필드를 통해 서로 공유되지 않는 메서드의 수를 측정하는 메트릭입니다.  
예를 들어, 클래스가 필드 a와 b를 가지고 있고, a와 b를 각각 접근하는 메서드들이 따로 있다면, 이 클래스의 LCOM 점수는 높기 때문에, 메서드 간의 응집도가 낮다.

LCOM 점수가 낮은 클래스는 응집도가 높고, LCOM 점수가 높은 클래스는 응집이 결여된 상태입니다.  LCOM은 아키텍처 스타일 전환 시 코드베이스를 분석하는 데 유용하며, 커플링된 클래스나 분리가 필요한 클래스를 발견하는 데 도움을 줍니다.

그러나 LCOM은 구조적 응집 결여만 측정할 뿐, 메서드와 필드가 논리적으로 잘 맞는지를 판단하지 못합니다. 이는 소프트웨어 아키텍처에서 ‘왜’보다 ‘어떻게’가 중요한 경우에 해당하는 메트릭입니다.

### 커플링
코드베이스의 커플링 분석에는 그래프 이론을 기반으로 한 많은 도구들이 있습니다.  
메서드 호출과 반환이 호출 그래프를 형성하기 때문에, 수학적으로 분석이 가능하다.  
대표적으로 에드워드 요던과 래리 콘스탄틴이 소개한 개념 중에는 **구심 커플링**(afferent coupling, 코드로 유입되는 연결 수, 다른 모듈에서 해당 모듈을 호출)과 **원심 커플링**(efferent coupling, 다른 코드로 유출되는 연결 수, 해당 모듈에서 다른 모듈을 호출)이 있습니다.  
이러한 커플링 특성 분석 도구들은 코드베이스를 재구성하거나 마이그레이션할 때 유용합니다.

###  3.2.3 추상도, 불안정도

컴포넌트 커플링은 아키텍트에게 중요한 메트릭으로, 추상도와 불안정도와 같은 파생 메트릭도 함께 고려해야 합니다. 

**추상도 (abstractness)**는 `추상 아티팩트(추상 클래스, 인터페이스 등)의 총 개수 / 구상 아티팩트(구현체)의 총 개수`로 계산되며, 코드가 얼마나 추상화되어 있는지를 나타냅니다. 추상도가 낮으면 코드가 분리되어 있지 않아서 모듈성이 떨어지고, 추상도가 너무 높으면 코드의 연결을 이해하기 어려워집니다.

**불안정도(instability)**는 `원심 커플링/(구심 커플링 + 원심 커플링)`으로 계산되며, 코드 베이스가 변경에 얼마나 민감한지를 측정합니다. 불안정도가 높은 코드베이스는 커플링이 많아 변경 시 쉽게 문제가 발생할 수 있습니다. 예를 들어 특정 모듈 코드의 대부분에서 다른 모듈을 호출하는 식으로 로직을 구성한 경우, 다른 모듈의 변경에 취약해집니다.

 ### 메인 시퀀스로부터의 거리
**메인 시퀀스로부터의 거리(Distance from the Main Sequence)**는 아키텍처 구조를 평가하는 메트릭 중 하나로, `|추상도 + 불안정도 - 1|`로 계산합니다. 추상도와 불안정도의 합이 1인 경우가 이상적인 관계인데, 이를 그래프로 표현하여 클래스가 이 이상적인 선에 얼마나 떨어져 있는지를 계산합니다. 선에 가까울수록 균형이 잘 맞는 구조입니다.

x 축을 불안 정도, y 축을 추상도로 두었을 때,
- 오른쪽 위는 지나치게 추상화되어 사용하기 어려운 쓸모없는 구역이고,
- 왼쪽 아래는 추상화가 부족해 유지보수가 어려운 고통스러운 구역입니다.

이 메트릭은 코드베이스를 분석할 때 클래스의 구조적 균형을 평가하는 데 유용합니다. 또한, 아키텍트가 코드의 기술 부채나 마이그레이션 필요성을 평가할 때 중요한 지표로 활용될 수 있습니다.

### 커네이선스(connascence)
두 컴포넌트가 서로 변경될 때 함께 변경되어야 한다면, 이들은 커네이선스(Connascence)를 갖고 있다. 이를 정적 커네이선스와 동적 커네이선스로 나누어 정의할 수 있다.

#### 정적 커네이선스 (Static Connascence):

1. **명칭 커네이선스 (CoN)**: 여러 컴포넌트가 동일한 엔티티명을 가져야 함. 예) 동일한 메서드명으로 컴포넌트를 호출해야 함
2. **타입 커네이선스 (CoT)**: 여러 컴포넌트의 엔티티 타입이 일치해야 함. 정적 타입 언어에서 기본 제공하는 기능.
3. **의미 커네이선스 (CoM)** 또는 **관례 커네이선스 (CoC)**: 여러 컴포넌트에서 값의 의미가 일치해야 함. 예) 하드코딩된 숫자 대신 상수를 사용해야 함
4. **위치 커네이선스 (CoP)**: 여러 컴포넌트에서 값의 순서가 일치해야 함. 예) 매개변수 순서를 지켜서 호출해야 함
5. **알고리즘 커네이선스 (CoA)**: 여러 컴포넌트에서 동일한 알고리즘을 사용해야 함. 예) 보안 해시 알고리즘을 이용한 클라이언트-서버 간 통신

#### 동적 커네이선스 (Dynamic Connascence):

1. **실행 커네이선스 (CoE)**: 여러 컴포넌트의 실행 순서가 중요함. 순서를 잘못하면 시스템이 제대로 작동하지 않음. 예) 정해진 순서로 프로퍼티 설정 메서드를 호출
2. **시점 커네이선스 (CoT)**: 여러 컴포넌트의 실행 시점이 중요함. 예) 동시에 실행 중인 두 스레드로 인해 경합 조건이 발생
3. **값 커네이선스 (CoV)**: 상호 연관된 값들이 함께 변경되어야 할 때 발생. 예) 분상 트랜잭션 설계 시 모든 데이터베이스에서 일괄적으로 값을 변경해야 함
4. **식별 커네이선스 (CoI)**: 여러 컴포넌트가 동일한 엔티티를 참조할 때 발생. 예) 독립된 컴포넌트들에서 분산 큐 같은 자료 구조를 공유

#### 케이넌스 속성
다음은 커네이선스의 주요 속성입니다:

1. 강도: 각 유형의 커네이선스의 리팩터링 난이도를 의미합니다. 정적 커네이선스는 소스 코드 분석을 통해 쉽게 개선할 수 있다. 매직 밸류 대신 기명 상수를 사용하는 것을 통해 의미 커네이선스를 명칭 커네이선스로 리팩터링하는 것이 한 예입니다. 동적 커네이선스는 더 복잡하고 다루기 어려운 편입니다.
   1. 명칭, 타입, 의미, 알고리즘, 위치, 실행, 타이밍, 값, 아이덴티티 순으로 어려움
2. 지역성: 커네이선스가 발생하는 코드들이 얼마나 가까이 있는지를 나타냅니다. 모듈 간 거리가 가까울수록 커플링을 쉽게 관리할 수 있습니다. 동일한 모듈 내에서 강한 커네이선스가 발견된다면, 여러 모듈에서 커플링이 분산되는 것보다 덜 해롭습니다.
3. 정도: 커네이선스가 미치는 영향의 규모를 나타냅니다. 영향이 적을수록 시스템에 더 바람직합니다. 모듈이 적을 때는 동적 커네이선스도 문제 되지 않지만, 코드베이스가 커지면 커플링 문제가 악화됩니다.

페이지-존스는 커네이선스를 줄이는 방법으로 다음을 제안했습니다:

1. 시스템을 잘게 나누어 커네이선스를 최소화한다.
2. 캡슐화 경계를 벗어나는 커네이선스를 줄인다.
3. 캡슐화 경계 내에서 커네이선스를 최대화한다.

짐 웨이리치는 두 가지 규칙을 제안했습니다:

1. 강도 규칙: 강한 커네이선스를 약한 커네이선스로 전환하라.
2. 지역성 규칙: 소프트웨어 요소 간의 거리가 멀어질수록 약한 형태의 커네이선스를 사용하라.

### 커플링과 커네이선스 메트릭을 통합
커플링(coupling)과 커네이선스(cohesion)는 아키텍트 관점에서 중첩됩니다. 커플링은 시스템 내 요소들이 서로 연결된 정도를 의미하며, 주로 데이터 흐름과 메서드 호출에 집중합니다. 반면, 커네이선스는 여러 요소가 어떻게 밀접하게 커플링 되는지에 중점을 둡니다.

다만 지금까지 살펴본1990년대의 커네이선스에는 일부 문제가 있다. 첫째, 커네이선스 메트릭이 아키텍처 구조보다는 저수준의 코드 품질에만 초점을 맞췄다는 점입니다. 아키텍트는 단순히 커플링 정도만을 살필 것이 아니라, 그들이 어떻게 커플링 되어 있는지(ex. 동기 통신 vs 비동기 통신)에 관심을 가져야 합니다. 둘째, 현대 아키텍트가 해결해야 할 동기/비동기 통신과 같은 근본적인 문제들을 다루지 않았다는 점입니다.

## 모듈에서 컴포넌트로
지금까지는 일반적인 용어인 모듈을 사용하여 연관된 코드의 묶음을 나타냈지만, 현재 대부분의 플랫폼에서는 이를 ‘컴포넌트’ 형태로 지원합니다. 
논리적, 물리적 분리에 대한 개념은 오래전부터 존재했지만, 여전히 컴포넌트와 분리에 대한 다양한 의견이 존재하며, 개발자와 아키텍트는 좋은 결과를 내기 위해 노력하고 있습니다. 
컴포넌트를 도출하는 방법은 8장에서 다룰 예정입니다.
